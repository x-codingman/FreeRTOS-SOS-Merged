
FreeRTOS-2-NS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000125c  00008000  00008000  00008000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000008  20002000  0000925c  00012000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00001204  20002020  00009280  00012020  2**5
                  ALLOC
  3 .heap         00000204  20003224  0000a484  00012020  2**0
                  ALLOC
  4 .stack        00000400  20003428  0000a688  00012020  2**0
                  ALLOC
  5 .ARM.attributes 0000002c  00000000  00000000  00012008  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00012034  2**0
                  CONTENTS, READONLY
  7 .debug_info   00006b7b  00000000  00000000  0001208d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000013fd  00000000  00000000  00018c08  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00003322  00000000  00000000  0001a005  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000004e8  00000000  00000000  0001d327  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000005a8  00000000  00000000  0001d80f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0001722b  00000000  00000000  0001ddb7  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00005cfc  00000000  00000000  00034fe2  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0008bddc  00000000  00000000  0003acde  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00000bb0  00000000  00000000  000c6abc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00008000 <exception_table>:
    8000:	28 38 00 20 71 81 00 00 6f 81 00 00 6f 81 00 00     (8. q...o...o...
	...
    802c:	41 89 00 00 00 00 00 00 00 00 00 00 a1 88 00 00     A...............
    803c:	51 86 00 00 6f 81 00 00 6f 81 00 00 6f 81 00 00     Q...o...o...o...
    804c:	6f 81 00 00 6f 81 00 00 6f 81 00 00 6f 81 00 00     o...o...o...o...
    805c:	6f 81 00 00 6f 81 00 00 6f 81 00 00 6f 81 00 00     o...o...o...o...
    806c:	6f 81 00 00 6f 81 00 00 6f 81 00 00 6f 81 00 00     o...o...o...o...
    807c:	6f 81 00 00 6f 81 00 00 6f 81 00 00 6f 81 00 00     o...o...o...o...
    808c:	6f 81 00 00 6f 81 00 00 6f 81 00 00 6f 81 00 00     o...o...o...o...
    809c:	6f 81 00 00 6f 81 00 00 6f 81 00 00 6f 81 00 00     o...o...o...o...
    80ac:	6f 81 00 00 6f 81 00 00 6f 81 00 00 6f 81 00 00     o...o...o...o...
    80bc:	6f 81 00 00 6f 81 00 00 6f 81 00 00 6f 81 00 00     o...o...o...o...
    80cc:	6f 81 00 00 6f 81 00 00 6f 81 00 00 6f 81 00 00     o...o...o...o...
    80dc:	6f 81 00 00 6f 81 00 00 6f 81 00 00 6f 81 00 00     o...o...o...o...
    80ec:	6f 81 00 00 6f 81 00 00                             o...o...

000080f4 <__do_global_dtors_aux>:
    80f4:	b510      	push	{r4, lr}
    80f6:	f242 0420 	movw	r4, #8224	; 0x2020
    80fa:	f2c2 0400 	movt	r4, #8192	; 0x2000
    80fe:	7823      	ldrb	r3, [r4, #0]
    8100:	b963      	cbnz	r3, 811c <__do_global_dtors_aux+0x28>
    8102:	f240 0300 	movw	r3, #0
    8106:	f2c0 0300 	movt	r3, #0
    810a:	b12b      	cbz	r3, 8118 <__do_global_dtors_aux+0x24>
    810c:	f249 205c 	movw	r0, #37468	; 0x925c
    8110:	f2c0 0000 	movt	r0, #0
    8114:	e000      	b.n	8118 <__do_global_dtors_aux+0x24>
    8116:	bf00      	nop
    8118:	2301      	movs	r3, #1
    811a:	7023      	strb	r3, [r4, #0]
    811c:	bd10      	pop	{r4, pc}
    811e:	46c0      	nop			; (mov r8, r8)

00008120 <frame_dummy>:
    8120:	f240 0300 	movw	r3, #0
    8124:	f2c0 0300 	movt	r3, #0
    8128:	b510      	push	{r4, lr}
    812a:	b14b      	cbz	r3, 8140 <frame_dummy+0x20>
    812c:	f242 0124 	movw	r1, #8228	; 0x2024
    8130:	f249 205c 	movw	r0, #37468	; 0x925c
    8134:	f2c2 0100 	movt	r1, #8192	; 0x2000
    8138:	f2c0 0000 	movt	r0, #0
    813c:	e000      	b.n	8140 <frame_dummy+0x20>
    813e:	bf00      	nop
    8140:	f249 205c 	movw	r0, #37468	; 0x925c
    8144:	f2c0 0000 	movt	r0, #0
    8148:	6803      	ldr	r3, [r0, #0]
    814a:	b903      	cbnz	r3, 814e <frame_dummy+0x2e>
    814c:	bd10      	pop	{r4, pc}
    814e:	f240 0300 	movw	r3, #0
    8152:	f2c0 0300 	movt	r3, #0
    8156:	2b00      	cmp	r3, #0
    8158:	d0f8      	beq.n	814c <frame_dummy+0x2c>
    815a:	4798      	blx	r3
    815c:	e7f6      	b.n	814c <frame_dummy+0x2c>
    815e:	46c0      	nop			; (mov r8, r8)

00008160 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
    8160:	b510      	push	{r4, lr}
	system_init();
    8162:	f248 2335 	movw	r3, #33333	; 0x8235
    8166:	f2c0 0300 	movt	r3, #0
    816a:	4798      	blx	r3
}
    816c:	bd10      	pop	{r4, pc}

0000816e <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    816e:	e7fe      	b.n	816e <Dummy_Handler>

00008170 <Reset_Handler>:
{
    8170:	b510      	push	{r4, lr}
        if (pSrc != pDest) {
    8172:	f249 225c 	movw	r2, #37468	; 0x925c
    8176:	f2c0 0200 	movt	r2, #0
    817a:	f242 0300 	movw	r3, #8192	; 0x2000
    817e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8182:	429a      	cmp	r2, r3
    8184:	d020      	beq.n	81c8 <Reset_Handler+0x58>
                for (; pDest < &_erelocate;) {
    8186:	001a      	movs	r2, r3
    8188:	f242 0308 	movw	r3, #8200	; 0x2008
    818c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8190:	429a      	cmp	r2, r3
    8192:	d219      	bcs.n	81c8 <Reset_Handler+0x58>
    8194:	f242 0308 	movw	r3, #8200	; 0x2008
    8198:	f2c2 0300 	movt	r3, #8192	; 0x2000
    819c:	3303      	adds	r3, #3
    819e:	4a24      	ldr	r2, [pc, #144]	; (8230 <Reset_Handler+0xc0>)
    81a0:	1a9b      	subs	r3, r3, r2
    81a2:	089b      	lsrs	r3, r3, #2
    81a4:	3301      	adds	r3, #1
    81a6:	009b      	lsls	r3, r3, #2
    81a8:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
    81aa:	f242 0100 	movw	r1, #8192	; 0x2000
    81ae:	f2c2 0100 	movt	r1, #8192	; 0x2000
    81b2:	1851      	adds	r1, r2, r1
    81b4:	f249 205c 	movw	r0, #37468	; 0x925c
    81b8:	f2c0 0000 	movt	r0, #0
    81bc:	1810      	adds	r0, r2, r0
    81be:	6800      	ldr	r0, [r0, #0]
    81c0:	6008      	str	r0, [r1, #0]
    81c2:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
    81c4:	429a      	cmp	r2, r3
    81c6:	d1f0      	bne.n	81aa <Reset_Handler+0x3a>
        for (pDest = &_szero; pDest < &_ezero;) {
    81c8:	f242 0220 	movw	r2, #8224	; 0x2020
    81cc:	f2c2 0200 	movt	r2, #8192	; 0x2000
    81d0:	f243 2324 	movw	r3, #12836	; 0x3224
    81d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    81d8:	429a      	cmp	r2, r3
    81da:	d213      	bcs.n	8204 <Reset_Handler+0x94>
    81dc:	f242 0220 	movw	r2, #8224	; 0x2020
    81e0:	f2c2 0200 	movt	r2, #8192	; 0x2000
    81e4:	43d3      	mvns	r3, r2
    81e6:	f243 2124 	movw	r1, #12836	; 0x3224
    81ea:	f2c2 0100 	movt	r1, #8192	; 0x2000
    81ee:	468c      	mov	ip, r1
    81f0:	4463      	add	r3, ip
    81f2:	2103      	movs	r1, #3
    81f4:	438b      	bics	r3, r1
    81f6:	3304      	adds	r3, #4
    81f8:	4694      	mov	ip, r2
    81fa:	4463      	add	r3, ip
                *pDest++ = 0;
    81fc:	2100      	movs	r1, #0
    81fe:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
    8200:	4293      	cmp	r3, r2
    8202:	d1fc      	bne.n	81fe <Reset_Handler+0x8e>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    8204:	f248 0300 	movw	r3, #32768	; 0x8000
    8208:	f2c0 0300 	movt	r3, #0
    820c:	227f      	movs	r2, #127	; 0x7f
    820e:	4393      	bics	r3, r2
    8210:	f64e 5200 	movw	r2, #60672	; 0xed00
    8214:	f2ce 0200 	movt	r2, #57344	; 0xe000
    8218:	6093      	str	r3, [r2, #8]
        __libc_init_array();
    821a:	f249 13a9 	movw	r3, #37289	; 0x91a9
    821e:	f2c0 0300 	movt	r3, #0
    8222:	4798      	blx	r3
        main();
    8224:	f248 5331 	movw	r3, #34097	; 0x8531
    8228:	f2c0 0300 	movt	r3, #0
    822c:	4798      	blx	r3
    822e:	e7fe      	b.n	822e <Reset_Handler+0xbe>
    8230:	20002004 	.word	0x20002004

00008234 <system_init>:
{
#if (defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U))
	/* Only initialize MCU clock when the project is TrustZone secure project  */
	init_mcu();
#endif
}
    8234:	4770      	bx	lr

00008236 <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
    8236:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    8238:	f242 033c 	movw	r3, #8252	; 0x203c
    823c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8240:	681c      	ldr	r4, [r3, #0]
    8242:	f248 437d 	movw	r3, #33917	; 0x847d
    8246:	f2c0 0300 	movt	r3, #0
    824a:	4798      	blx	r3
    824c:	0001      	movs	r1, r0
    824e:	0020      	movs	r0, r4
    8250:	f248 4395 	movw	r3, #33941	; 0x8495
    8254:	f2c0 0300 	movt	r3, #0
    8258:	4798      	blx	r3
}
    825a:	bd10      	pop	{r4, pc}

0000825c <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
    825c:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    825e:	f242 0340 	movw	r3, #8256	; 0x2040
    8262:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8266:	681a      	ldr	r2, [r3, #0]
    8268:	4282      	cmp	r2, r0
    826a:	d31c      	bcc.n	82a6 <prvInsertBlockIntoFreeList+0x4a>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    826c:	685c      	ldr	r4, [r3, #4]
    826e:	1919      	adds	r1, r3, r4
    8270:	4288      	cmp	r0, r1
    8272:	d103      	bne.n	827c <prvInsertBlockIntoFreeList+0x20>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    8274:	6841      	ldr	r1, [r0, #4]
    8276:	1909      	adds	r1, r1, r4
    8278:	6059      	str	r1, [r3, #4]
    827a:	0018      	movs	r0, r3
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    827c:	6844      	ldr	r4, [r0, #4]
    827e:	1901      	adds	r1, r0, r4
    8280:	428a      	cmp	r2, r1
    8282:	d114      	bne.n	82ae <prvInsertBlockIntoFreeList+0x52>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    8284:	f242 0140 	movw	r1, #8256	; 0x2040
    8288:	f2c2 0100 	movt	r1, #8192	; 0x2000
    828c:	6889      	ldr	r1, [r1, #8]
    828e:	428a      	cmp	r2, r1
    8290:	d00b      	beq.n	82aa <prvInsertBlockIntoFreeList+0x4e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    8292:	6852      	ldr	r2, [r2, #4]
    8294:	1912      	adds	r2, r2, r4
    8296:	6042      	str	r2, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    8298:	681a      	ldr	r2, [r3, #0]
    829a:	6812      	ldr	r2, [r2, #0]
    829c:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    829e:	4298      	cmp	r0, r3
    82a0:	d000      	beq.n	82a4 <prvInsertBlockIntoFreeList+0x48>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    82a2:	6018      	str	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    82a4:	bd10      	pop	{r4, pc}
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    82a6:	0013      	movs	r3, r2
    82a8:	e7dd      	b.n	8266 <prvInsertBlockIntoFreeList+0xa>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    82aa:	6002      	str	r2, [r0, #0]
    82ac:	e7f7      	b.n	829e <prvInsertBlockIntoFreeList+0x42>
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    82ae:	6002      	str	r2, [r0, #0]
    82b0:	e7f5      	b.n	829e <prvInsertBlockIntoFreeList+0x42>

000082b2 <pvPortMalloc>:
{
    82b2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    82b4:	0004      	movs	r4, r0
	vTaskSuspendAll();
    82b6:	f648 5363 	movw	r3, #36195	; 0x8d63
    82ba:	f2c0 0300 	movt	r3, #0
    82be:	4798      	blx	r3
		if( pxEnd == NULL )
    82c0:	f242 0340 	movw	r3, #8256	; 0x2040
    82c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    82c8:	689b      	ldr	r3, [r3, #8]
    82ca:	b30b      	cbz	r3, 8310 <pvPortMalloc+0x5e>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    82cc:	f642 4340 	movw	r3, #11328	; 0x2c40
    82d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    82d4:	695e      	ldr	r6, [r3, #20]
    82d6:	4234      	tst	r4, r6
    82d8:	d000      	beq.n	82dc <pvPortMalloc+0x2a>
    82da:	e08b      	b.n	83f4 <pvPortMalloc+0x142>
			if( xWantedSize > 0 )
    82dc:	2c00      	cmp	r4, #0
    82de:	d100      	bne.n	82e2 <pvPortMalloc+0x30>
    82e0:	e08f      	b.n	8402 <pvPortMalloc+0x150>
				xWantedSize += xHeapStructSize;
    82e2:	0023      	movs	r3, r4
    82e4:	3308      	adds	r3, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    82e6:	075a      	lsls	r2, r3, #29
    82e8:	d002      	beq.n	82f0 <pvPortMalloc+0x3e>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    82ea:	2207      	movs	r2, #7
    82ec:	4393      	bics	r3, r2
    82ee:	3308      	adds	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    82f0:	2b00      	cmp	r3, #0
    82f2:	d100      	bne.n	82f6 <pvPortMalloc+0x44>
    82f4:	e07e      	b.n	83f4 <pvPortMalloc+0x142>
    82f6:	f642 4240 	movw	r2, #11328	; 0x2c40
    82fa:	f2c2 0200 	movt	r2, #8192	; 0x2000
    82fe:	6915      	ldr	r5, [r2, #16]
    8300:	42ab      	cmp	r3, r5
    8302:	d877      	bhi.n	83f4 <pvPortMalloc+0x142>
				pxBlock = xStart.pxNextFreeBlock;
    8304:	f242 0240 	movw	r2, #8256	; 0x2040
    8308:	f2c2 0200 	movt	r2, #8192	; 0x2000
    830c:	6814      	ldr	r4, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    830e:	e02d      	b.n	836c <pvPortMalloc+0xba>
	uxAddress = ( size_t ) ucHeap;
    8310:	f242 0340 	movw	r3, #8256	; 0x2040
    8314:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8318:	330c      	adds	r3, #12
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
    831a:	f640 4200 	movw	r2, #3072	; 0xc00
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    831e:	0759      	lsls	r1, r3, #29
    8320:	d007      	beq.n	8332 <pvPortMalloc+0x80>
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
    8322:	1dd9      	adds	r1, r3, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    8324:	2207      	movs	r2, #7
    8326:	4391      	bics	r1, r2
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
    8328:	f640 4c00 	movw	ip, #3072	; 0xc00
    832c:	4463      	add	r3, ip
    832e:	1a5a      	subs	r2, r3, r1
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    8330:	000b      	movs	r3, r1
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    8332:	f242 0140 	movw	r1, #8256	; 0x2040
    8336:	f2c2 0100 	movt	r1, #8192	; 0x2000
    833a:	600b      	str	r3, [r1, #0]
	xStart.xBlockSize = ( size_t ) 0;
    833c:	2000      	movs	r0, #0
    833e:	6048      	str	r0, [r1, #4]
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
    8340:	189a      	adds	r2, r3, r2
	uxAddress -= xHeapStructSize;
    8342:	3a08      	subs	r2, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    8344:	2507      	movs	r5, #7
    8346:	43aa      	bics	r2, r5
	pxEnd = ( void * ) uxAddress;
    8348:	608a      	str	r2, [r1, #8]
	pxEnd->xBlockSize = 0;
    834a:	6050      	str	r0, [r2, #4]
	pxEnd->pxNextFreeBlock = NULL;
    834c:	6010      	str	r0, [r2, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    834e:	1ad1      	subs	r1, r2, r3
    8350:	6059      	str	r1, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    8352:	601a      	str	r2, [r3, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    8354:	f642 4340 	movw	r3, #11328	; 0x2c40
    8358:	f2c2 0300 	movt	r3, #8192	; 0x2000
    835c:	60d9      	str	r1, [r3, #12]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    835e:	6119      	str	r1, [r3, #16]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    8360:	2280      	movs	r2, #128	; 0x80
    8362:	0612      	lsls	r2, r2, #24
    8364:	615a      	str	r2, [r3, #20]
    8366:	e7b1      	b.n	82cc <pvPortMalloc+0x1a>
    8368:	0022      	movs	r2, r4
					pxBlock = pxBlock->pxNextFreeBlock;
    836a:	000c      	movs	r4, r1
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    836c:	6861      	ldr	r1, [r4, #4]
    836e:	428b      	cmp	r3, r1
    8370:	d902      	bls.n	8378 <pvPortMalloc+0xc6>
    8372:	6821      	ldr	r1, [r4, #0]
    8374:	2900      	cmp	r1, #0
    8376:	d1f7      	bne.n	8368 <pvPortMalloc+0xb6>
				if( pxBlock != pxEnd )
    8378:	f242 0140 	movw	r1, #8256	; 0x2040
    837c:	f2c2 0100 	movt	r1, #8192	; 0x2000
    8380:	6889      	ldr	r1, [r1, #8]
    8382:	428c      	cmp	r4, r1
    8384:	d036      	beq.n	83f4 <pvPortMalloc+0x142>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    8386:	6817      	ldr	r7, [r2, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    8388:	6821      	ldr	r1, [r4, #0]
    838a:	6011      	str	r1, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    838c:	6862      	ldr	r2, [r4, #4]
    838e:	1ad2      	subs	r2, r2, r3
    8390:	2a10      	cmp	r2, #16
    8392:	d90b      	bls.n	83ac <pvPortMalloc+0xfa>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    8394:	18e0      	adds	r0, r4, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
    8396:	0741      	lsls	r1, r0, #29
    8398:	d001      	beq.n	839e <pvPortMalloc+0xec>
    839a:	b672      	cpsid	i
    839c:	e7fe      	b.n	839c <pvPortMalloc+0xea>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    839e:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
    83a0:	6063      	str	r3, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
    83a2:	f248 235d 	movw	r3, #33373	; 0x825d
    83a6:	f2c0 0300 	movt	r3, #0
    83aa:	4798      	blx	r3
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    83ac:	6861      	ldr	r1, [r4, #4]
    83ae:	1a6d      	subs	r5, r5, r1
    83b0:	f642 4240 	movw	r2, #11328	; 0x2c40
    83b4:	f2c2 0200 	movt	r2, #8192	; 0x2000
    83b8:	6115      	str	r5, [r2, #16]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    83ba:	68d2      	ldr	r2, [r2, #12]
    83bc:	4295      	cmp	r5, r2
    83be:	d204      	bcs.n	83ca <pvPortMalloc+0x118>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    83c0:	f642 4240 	movw	r2, #11328	; 0x2c40
    83c4:	f2c2 0200 	movt	r2, #8192	; 0x2000
    83c8:	60d5      	str	r5, [r2, #12]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    83ca:	3708      	adds	r7, #8
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    83cc:	430e      	orrs	r6, r1
    83ce:	6066      	str	r6, [r4, #4]
					pxBlock->pxNextFreeBlock = NULL;
    83d0:	2300      	movs	r3, #0
    83d2:	6023      	str	r3, [r4, #0]
					xNumberOfSuccessfulAllocations++;
    83d4:	f642 4340 	movw	r3, #11328	; 0x2c40
    83d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    83dc:	699a      	ldr	r2, [r3, #24]
    83de:	3201      	adds	r2, #1
    83e0:	619a      	str	r2, [r3, #24]
	( void ) xTaskResumeAll();
    83e2:	f648 63bb 	movw	r3, #36539	; 0x8ebb
    83e6:	f2c0 0300 	movt	r3, #0
    83ea:	4798      	blx	r3
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
    83ec:	077b      	lsls	r3, r7, #29
    83ee:	d00e      	beq.n	840e <pvPortMalloc+0x15c>
    83f0:	b672      	cpsid	i
    83f2:	e7fe      	b.n	83f2 <pvPortMalloc+0x140>
	( void ) xTaskResumeAll();
    83f4:	f648 63bb 	movw	r3, #36539	; 0x8ebb
    83f8:	f2c0 0300 	movt	r3, #0
    83fc:	4798      	blx	r3
    83fe:	2700      	movs	r7, #0
    8400:	e005      	b.n	840e <pvPortMalloc+0x15c>
    8402:	f648 63bb 	movw	r3, #36539	; 0x8ebb
    8406:	f2c0 0300 	movt	r3, #0
    840a:	4798      	blx	r3
void *pvReturn = NULL;
    840c:	2700      	movs	r7, #0
}
    840e:	0038      	movs	r0, r7
    8410:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00008412 <vPortFree>:
{
    8412:	b570      	push	{r4, r5, r6, lr}
	if( pv != NULL )
    8414:	b388      	cbz	r0, 847a <vPortFree+0x68>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
    8416:	0003      	movs	r3, r0
    8418:	3b08      	subs	r3, #8
    841a:	685b      	ldr	r3, [r3, #4]
    841c:	f642 4240 	movw	r2, #11328	; 0x2c40
    8420:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8424:	6952      	ldr	r2, [r2, #20]
    8426:	421a      	tst	r2, r3
    8428:	d101      	bne.n	842e <vPortFree+0x1c>
    842a:	b672      	cpsid	i
    842c:	e7fe      	b.n	842c <vPortFree+0x1a>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
    842e:	0001      	movs	r1, r0
    8430:	3908      	subs	r1, #8
    8432:	6809      	ldr	r1, [r1, #0]
    8434:	b109      	cbz	r1, 843a <vPortFree+0x28>
    8436:	b672      	cpsid	i
    8438:	e7fe      	b.n	8438 <vPortFree+0x26>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    843a:	3808      	subs	r0, #8
    843c:	0004      	movs	r4, r0
    843e:	4393      	bics	r3, r2
    8440:	6043      	str	r3, [r0, #4]
				vTaskSuspendAll();
    8442:	f648 5363 	movw	r3, #36195	; 0x8d63
    8446:	f2c0 0300 	movt	r3, #0
    844a:	4798      	blx	r3
					xFreeBytesRemaining += pxLink->xBlockSize;
    844c:	f642 4540 	movw	r5, #11328	; 0x2c40
    8450:	f2c2 0500 	movt	r5, #8192	; 0x2000
    8454:	6863      	ldr	r3, [r4, #4]
    8456:	692a      	ldr	r2, [r5, #16]
    8458:	4694      	mov	ip, r2
    845a:	4463      	add	r3, ip
    845c:	612b      	str	r3, [r5, #16]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    845e:	0020      	movs	r0, r4
    8460:	f248 235d 	movw	r3, #33373	; 0x825d
    8464:	f2c0 0300 	movt	r3, #0
    8468:	4798      	blx	r3
					xNumberOfSuccessfulFrees++;
    846a:	69eb      	ldr	r3, [r5, #28]
    846c:	3301      	adds	r3, #1
    846e:	61eb      	str	r3, [r5, #28]
				( void ) xTaskResumeAll();
    8470:	f648 63bb 	movw	r3, #36539	; 0x8ebb
    8474:	f2c0 0300 	movt	r3, #0
    8478:	4798      	blx	r3
}
    847a:	bd70      	pop	{r4, r5, r6, pc}

0000847c <_get_cycles_for_ms>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
    847c:	0003      	movs	r3, r0
		return (ms * (freq / 10000) + 2) / 3 * 10;
    847e:	f240 1090 	movw	r0, #400	; 0x190
    8482:	4358      	muls	r0, r3
    8484:	3002      	adds	r0, #2
    8486:	2303      	movs	r3, #3
    8488:	fbb0 f0f3 	udiv	r0, r0, r3
    848c:	0083      	lsls	r3, r0, #2
    848e:	1818      	adds	r0, r3, r0
    8490:	0040      	lsls	r0, r0, #1
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
    8492:	4770      	bx	lr

00008494 <_delay_cycles>:
#if defined(__GNUC__) && (__ARMCOMPILER_VERSION > 6000000) /*  Keil MDK with ARM Compiler 6 */
	__asm("__delay:\n"
	      "subs r1, r1, #1\n"
	      "bhi __delay\n");
#elif defined __GNUC__
	__asm(".syntax unified\n"
    8494:	3901      	subs	r1, #1
    8496:	d8fd      	bhi.n	8494 <_delay_cycles>
	__asm("__delay:\n"
	      "subs r1, r1, #1\n"
	      "bhi __delay\n");
#endif
#endif
}
    8498:	4770      	bx	lr

0000849a <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    849a:	0003      	movs	r3, r0
    849c:	3308      	adds	r3, #8
    849e:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    84a0:	2201      	movs	r2, #1
    84a2:	4252      	negs	r2, r2
    84a4:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    84a6:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    84a8:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    84aa:	2300      	movs	r3, #0
    84ac:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    84ae:	4770      	bx	lr

000084b0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    84b0:	2300      	movs	r3, #0
    84b2:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    84b4:	4770      	bx	lr

000084b6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
    84b6:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    84b8:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    84ba:	689a      	ldr	r2, [r3, #8]
    84bc:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    84be:	689a      	ldr	r2, [r3, #8]
    84c0:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
    84c2:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    84c4:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
    84c6:	6803      	ldr	r3, [r0, #0]
    84c8:	3301      	adds	r3, #1
    84ca:	6003      	str	r3, [r0, #0]
}
    84cc:	4770      	bx	lr

000084ce <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    84ce:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    84d0:	6842      	ldr	r2, [r0, #4]
    84d2:	6881      	ldr	r1, [r0, #8]
    84d4:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    84d6:	6882      	ldr	r2, [r0, #8]
    84d8:	6841      	ldr	r1, [r0, #4]
    84da:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    84dc:	685a      	ldr	r2, [r3, #4]
    84de:	4290      	cmp	r0, r2
    84e0:	d006      	beq.n	84f0 <uxListRemove+0x22>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    84e2:	2200      	movs	r2, #0
    84e4:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
    84e6:	681a      	ldr	r2, [r3, #0]
    84e8:	3a01      	subs	r2, #1
    84ea:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    84ec:	6818      	ldr	r0, [r3, #0]
}
    84ee:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    84f0:	6882      	ldr	r2, [r0, #8]
    84f2:	605a      	str	r2, [r3, #4]
    84f4:	e7f5      	b.n	84e2 <uxListRemove+0x14>

000084f6 <vTask1>:
	}
	return;
}


void vTask1( void *pvParameters ){
    84f6:	b570      	push	{r4, r5, r6, lr}
    84f8:	b082      	sub	sp, #8
	const char* str="hello,lm task1\r\n";
	uint32_t reuslt;
	uint32_t test_module_id=0x1234;
	uint32_t command_id=0x1;
	uint32_t operation;
	reuslt=nsc_invoke_command(test_module_id,command_id,&operation);
    84fa:	aa01      	add	r2, sp, #4
    84fc:	2101      	movs	r1, #1
    84fe:	f241 2034 	movw	r0, #4660	; 0x1234
    8502:	f647 4341 	movw	r3, #31809	; 0x7c41
    8506:	f2c0 0300 	movt	r3, #0
    850a:	4798      	blx	r3
	while(1){
		nsc_printf(str);
    850c:	f249 2608 	movw	r6, #37384	; 0x9208
    8510:	f2c0 0600 	movt	r6, #0
    8514:	f647 4521 	movw	r5, #31777	; 0x7c21
    8518:	f2c0 0500 	movt	r5, #0
		delay_ms(1000);
    851c:	f248 2437 	movw	r4, #33335	; 0x8237
    8520:	f2c0 0400 	movt	r4, #0
		nsc_printf(str);
    8524:	0030      	movs	r0, r6
    8526:	47a8      	blx	r5
		delay_ms(1000);
    8528:	f240 30e8 	movw	r0, #1000	; 0x3e8
    852c:	47a0      	blx	r4
    852e:	e7f9      	b.n	8524 <vTask1+0x2e>

00008530 <main>:
{
    8530:	b510      	push	{r4, lr}
    8532:	b082      	sub	sp, #8
	atmel_start_init();
    8534:	f248 1361 	movw	r3, #33121	; 0x8161
    8538:	f2c0 0300 	movt	r3, #0
    853c:	4798      	blx	r3
	delay_ms(1000);
    853e:	f240 30e8 	movw	r0, #1000	; 0x3e8
    8542:	f248 2337 	movw	r3, #33335	; 0x8237
    8546:	f2c0 0300 	movt	r3, #0
    854a:	4798      	blx	r3
	 xTaskCreate( vTask1, /* Pointer to the function that implements the task. */
    854c:	f249 211c 	movw	r1, #37404	; 0x921c
    8550:	f2c0 0100 	movt	r1, #0
    8554:	f248 40f7 	movw	r0, #34039	; 0x84f7
    8558:	f2c0 0000 	movt	r0, #0
    855c:	2300      	movs	r3, #0
    855e:	9301      	str	r3, [sp, #4]
    8560:	3302      	adds	r3, #2
    8562:	9300      	str	r3, [sp, #0]
    8564:	2300      	movs	r3, #0
    8566:	2264      	movs	r2, #100	; 0x64
    8568:	f648 4479 	movw	r4, #35961	; 0x8c79
    856c:	f2c0 0400 	movt	r4, #0
    8570:	47a0      	blx	r4
	 vTaskStartScheduler(); 
    8572:	f648 43ef 	movw	r3, #36079	; 0x8cef
    8576:	f2c0 0300 	movt	r3, #0
    857a:	4798      	blx	r3
		__NOP();
    857c:	46c0      	nop			; (mov r8, r8)
    857e:	e7fd      	b.n	857c <main+0x4c>

00008580 <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName )
{
	/* Force an assert. */
	
	configASSERT( pcTaskName == 0 );
    8580:	b109      	cbz	r1, 8586 <vApplicationStackOverflowHook+0x6>
    8582:	b672      	cpsid	i
    8584:	e7fe      	b.n	8584 <vApplicationStackOverflowHook+0x4>
}
    8586:	4770      	bx	lr

00008588 <vApplicationGetIdleTaskMemory>:
	static StaticTask_t xIdleTaskTCB;
	static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ] __attribute__( ( aligned( 32 ) ) );

	/* Pass out a pointer to the StaticTask_t structure in which the Idle
	 * task's state will be stored. */
	*ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
    8588:	f642 4360 	movw	r3, #11360	; 0x2c60
    858c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8590:	6003      	str	r3, [r0, #0]

	/* Pass out the array that will be used as the Idle task's stack. */
	*ppxIdleTaskStackBuffer = uxIdleTaskStack;
    8592:	3360      	adds	r3, #96	; 0x60
    8594:	600b      	str	r3, [r1, #0]

	/* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer.
	 * Note that, as the array is necessarily of type StackType_t,
	 * configMINIMAL_STACK_SIZE is specified in words, not bytes. */
	*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    8596:	2380      	movs	r3, #128	; 0x80
    8598:	6013      	str	r3, [r2, #0]
}
    859a:	4770      	bx	lr

0000859c <prvTaskExitError>:
	*( portNVIC_SYSTICK_CTRL ) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
    859c:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0UL;
    859e:	2300      	movs	r3, #0
    85a0:	9301      	str	r3, [sp, #4]
	/* A function that implements a task must not exit or attempt to return to
	 * its caller as there is nothing to return to. If a task wants to exit it
	 * should instead call vTaskDelete( NULL ). Artificially force an assert()
	 * to be triggered if configASSERT() is defined, then stop here so
	 * application writers can catch the error. */
	configASSERT( ulCriticalNesting == ~0UL );
    85a2:	f242 0304 	movw	r3, #8196	; 0x2004
    85a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    85aa:	681b      	ldr	r3, [r3, #0]
    85ac:	3301      	adds	r3, #1
    85ae:	d001      	beq.n	85b4 <prvTaskExitError+0x18>
    85b0:	b672      	cpsid	i
    85b2:	e7fe      	b.n	85b2 <prvTaskExitError+0x16>
	portDISABLE_INTERRUPTS();
    85b4:	b672      	cpsid	i

	while( ulDummy == 0 )
    85b6:	9b01      	ldr	r3, [sp, #4]
    85b8:	2b00      	cmp	r3, #0
    85ba:	d0fc      	beq.n	85b6 <prvTaskExitError+0x1a>
		 * warnings about code appearing after this function is called - making
		 * ulDummy volatile makes the compiler think the function could return
		 * and therefore not output an 'unreachable code' warning for code that
		 * appears after it. */
	}
}
    85bc:	b002      	add	sp, #8
    85be:	4770      	bx	lr

000085c0 <vPortSetupTimerInterrupt>:
	*( portNVIC_SYSTICK_CTRL ) = 0UL;
    85c0:	f24e 0210 	movw	r2, #57360	; 0xe010
    85c4:	f2ce 0200 	movt	r2, #57344	; 0xe000
    85c8:	2100      	movs	r1, #0
    85ca:	6011      	str	r1, [r2, #0]
	*( portNVIC_SYSTICK_CURRENT_VALUE ) = 0UL;
    85cc:	f24e 0318 	movw	r3, #57368	; 0xe018
    85d0:	f2ce 0300 	movt	r3, #57344	; 0xe000
    85d4:	6019      	str	r1, [r3, #0]
	*( portNVIC_SYSTICK_LOAD ) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
    85d6:	f242 0300 	movw	r3, #8192	; 0x2000
    85da:	f2c2 0300 	movt	r3, #8192	; 0x2000
    85de:	681b      	ldr	r3, [r3, #0]
    85e0:	3164      	adds	r1, #100	; 0x64
    85e2:	fbb3 f3f1 	udiv	r3, r3, r1
    85e6:	3b01      	subs	r3, #1
    85e8:	f24e 0114 	movw	r1, #57364	; 0xe014
    85ec:	f2ce 0100 	movt	r1, #57344	; 0xe000
    85f0:	600b      	str	r3, [r1, #0]
	*( portNVIC_SYSTICK_CTRL ) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
    85f2:	2307      	movs	r3, #7
    85f4:	6013      	str	r3, [r2, #0]
}
    85f6:	4770      	bx	lr

000085f8 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void ) /* PRIVILEGED_FUNCTION */
{
	/* Set a PendSV to request a context switch. */
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
    85f8:	f64e 5304 	movw	r3, #60676	; 0xed04
    85fc:	f2ce 0300 	movt	r3, #57344	; 0xe000
    8600:	2280      	movs	r2, #128	; 0x80
    8602:	0552      	lsls	r2, r2, #21
    8604:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is
	 * completely within the specified behaviour for the architecture. */
	__asm volatile( "dsb" ::: "memory" );
    8606:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
    860a:	f3bf 8f6f 	isb	sy
}
    860e:	4770      	bx	lr

00008610 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */
{
	portDISABLE_INTERRUPTS();
    8610:	b672      	cpsid	i
	ulCriticalNesting++;
    8612:	f242 0304 	movw	r3, #8196	; 0x2004
    8616:	f2c2 0300 	movt	r3, #8192	; 0x2000
    861a:	681a      	ldr	r2, [r3, #0]
    861c:	3201      	adds	r2, #1
    861e:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is
	 * completely within the specified behaviour for the architecture. */
	__asm volatile( "dsb" ::: "memory" );
    8620:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
    8624:	f3bf 8f6f 	isb	sy
}
    8628:	4770      	bx	lr

0000862a <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */
{
	configASSERT( ulCriticalNesting );
    862a:	f242 0304 	movw	r3, #8196	; 0x2004
    862e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8632:	681b      	ldr	r3, [r3, #0]
    8634:	b90b      	cbnz	r3, 863a <vPortExitCritical+0x10>
    8636:	b672      	cpsid	i
    8638:	e7fe      	b.n	8638 <vPortExitCritical+0xe>
	ulCriticalNesting--;
    863a:	f242 0304 	movw	r3, #8196	; 0x2004
    863e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8642:	681a      	ldr	r2, [r3, #0]
    8644:	3a01      	subs	r2, #1
    8646:	601a      	str	r2, [r3, #0]

	if( ulCriticalNesting == 0 )
    8648:	681b      	ldr	r3, [r3, #0]
    864a:	b903      	cbnz	r3, 864e <vPortExitCritical+0x24>
	{
		portENABLE_INTERRUPTS();
    864c:	b662      	cpsie	i
	}
}
    864e:	4770      	bx	lr

00008650 <SysTick_Handler>:
/*-----------------------------------------------------------*/

void SysTick_Handler( void ) /* PRIVILEGED_FUNCTION */
{
    8650:	b510      	push	{r4, lr}
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
    8652:	f648 0385 	movw	r3, #34949	; 0x8885
    8656:	f2c0 0300 	movt	r3, #0
    865a:	4798      	blx	r3
    865c:	0004      	movs	r4, r0
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
    865e:	f648 5373 	movw	r3, #36211	; 0x8d73
    8662:	f2c0 0300 	movt	r3, #0
    8666:	4798      	blx	r3
    8668:	b130      	cbz	r0, 8678 <SysTick_Handler+0x28>
		{
			/* Pend a context switch. */
			*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
    866a:	f64e 5304 	movw	r3, #60676	; 0xed04
    866e:	f2ce 0300 	movt	r3, #57344	; 0xe000
    8672:	2280      	movs	r2, #128	; 0x80
    8674:	0552      	lsls	r2, r2, #21
    8676:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
    8678:	0020      	movs	r0, r4
    867a:	f648 038d 	movw	r3, #34957	; 0x888d
    867e:	f2c0 0300 	movt	r3, #0
    8682:	4798      	blx	r3
}
    8684:	bd10      	pop	{r4, pc}

00008686 <vPortSVCHandler_C>:
/*-----------------------------------------------------------*/

void vPortSVCHandler_C( uint32_t *pulCallerStackAddress ) /* PRIVILEGED_FUNCTION portDONT_DISCARD */
{
    8686:	b510      	push	{r4, lr}
uint8_t ucSVCNumber;

	/* Register are stored on the stack in the following order - R0, R1, R2, R3,
	 * R12, LR, PC, xPSR. */
	ulPC = pulCallerStackAddress[ 6 ];
	ucSVCNumber = ( ( uint8_t *) ulPC )[ -2 ];
    8688:	6983      	ldr	r3, [r0, #24]
    868a:	3b02      	subs	r3, #2

	switch( ucSVCNumber )
    868c:	781b      	ldrb	r3, [r3, #0]
    868e:	2b01      	cmp	r3, #1
    8690:	d01e      	beq.n	86d0 <vPortSVCHandler_C+0x4a>
    8692:	b11b      	cbz	r3, 869c <vPortSVCHandler_C+0x16>
    8694:	2b02      	cmp	r3, #2
    8696:	d022      	beq.n	86de <vPortSVCHandler_C+0x58>
		#endif /* configENABLE_MPU */

		default:
		{
			/* Incorrect SVC call. */
			configASSERT( pdFALSE );
    8698:	b672      	cpsid	i
    869a:	e7fe      	b.n	869a <vPortSVCHandler_C+0x14>
					xSecureContext = SecureContext_AllocateContext( ulR0 );
    869c:	6800      	ldr	r0, [r0, #0]
    869e:	f647 4309 	movw	r3, #31753	; 0x7c09
    86a2:	f2c0 0300 	movt	r3, #0
    86a6:	4798      	blx	r3
    86a8:	f243 1320 	movw	r3, #12576	; 0x3120
    86ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
    86b0:	6018      	str	r0, [r3, #0]
				configASSERT( xSecureContext != NULL );
    86b2:	681b      	ldr	r3, [r3, #0]
    86b4:	b153      	cbz	r3, 86cc <vPortSVCHandler_C+0x46>
				SecureContext_LoadContext( xSecureContext );
    86b6:	f243 1320 	movw	r3, #12576	; 0x3120
    86ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
    86be:	6818      	ldr	r0, [r3, #0]
    86c0:	f647 4331 	movw	r3, #31793	; 0x7c31
    86c4:	f2c0 0300 	movt	r3, #0
    86c8:	4798      	blx	r3
		}
	}
}
    86ca:	bd10      	pop	{r4, pc}
				configASSERT( xSecureContext != NULL );
    86cc:	b672      	cpsid	i
    86ce:	e7fe      	b.n	86ce <vPortSVCHandler_C+0x48>
				SecureContext_FreeContext( ( SecureContextHandle_t ) ulR0 );
    86d0:	6800      	ldr	r0, [r0, #0]
    86d2:	f647 4351 	movw	r3, #31825	; 0x7c51
    86d6:	f2c0 0300 	movt	r3, #0
    86da:	4798      	blx	r3
			break;
    86dc:	e7f5      	b.n	86ca <vPortSVCHandler_C+0x44>
				SecureInit_DePrioritizeNSExceptions();
    86de:	f647 4301 	movw	r3, #31745	; 0x7c01
    86e2:	f2c0 0300 	movt	r3, #0
    86e6:	4798      	blx	r3
				SecureContext_Init();
    86e8:	f647 4329 	movw	r3, #31785	; 0x7c29
    86ec:	f2c0 0300 	movt	r3, #0
    86f0:	4798      	blx	r3
			vRestoreContextOfFirstTask();
    86f2:	f648 0321 	movw	r3, #34849	; 0x8821
    86f6:	f2c0 0300 	movt	r3, #0
    86fa:	4798      	blx	r3
		break;
    86fc:	e7e5      	b.n	86ca <vPortSVCHandler_C+0x44>

000086fe <pxPortInitialiseStack>:
#if( configENABLE_MPU == 1 )
	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) /* PRIVILEGED_FUNCTION */
#else
	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, StackType_t *pxEndOfStack, TaskFunction_t pxCode, void *pvParameters ) /* PRIVILEGED_FUNCTION */
#endif /* configENABLE_MPU */
{
    86fe:	b530      	push	{r4, r5, lr}
		#endif /* configENABLE_TRUSTZONE */
	}
	#else /* portPRELOAD_REGISTERS */
	{
		pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
		*pxTopOfStack = portINITIAL_XPSR;							/* xPSR */
    8700:	1f04      	subs	r4, r0, #4
    8702:	2580      	movs	r5, #128	; 0x80
    8704:	046d      	lsls	r5, r5, #17
    8706:	6025      	str	r5, [r4, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) pxCode;						/* PC */
    8708:	3c04      	subs	r4, #4
    870a:	6022      	str	r2, [r4, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
    870c:	3c04      	subs	r4, #4
    870e:	f248 529d 	movw	r2, #34205	; 0x859d
    8712:	f2c0 0200 	movt	r2, #0
    8716:	6022      	str	r2, [r4, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) 0x12121212UL;				/* R12 */
    8718:	3c04      	subs	r4, #4
    871a:	f241 2212 	movw	r2, #4626	; 0x1212
    871e:	f2c1 2212 	movt	r2, #4626	; 0x1212
    8722:	6022      	str	r2, [r4, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) 0x03030303UL;				/* R3 */
    8724:	3c04      	subs	r4, #4
    8726:	f240 3203 	movw	r2, #771	; 0x303
    872a:	f2c0 3203 	movt	r2, #771	; 0x303
    872e:	6022      	str	r2, [r4, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) 0x02020202UL;				/* R2 */
    8730:	3c04      	subs	r4, #4
    8732:	f240 2202 	movw	r2, #514	; 0x202
    8736:	f2c0 2202 	movt	r2, #514	; 0x202
    873a:	6022      	str	r2, [r4, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) 0x01010101UL;				/* R1 */
    873c:	3c04      	subs	r4, #4
    873e:	f240 1201 	movw	r2, #257	; 0x101
    8742:	f2c0 1201 	movt	r2, #257	; 0x101
    8746:	6022      	str	r2, [r4, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) pvParameters;				/* R0 */
    8748:	0002      	movs	r2, r0
    874a:	3a20      	subs	r2, #32
    874c:	6013      	str	r3, [r2, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) 0x11111111UL;				/* R11 */
    874e:	3a04      	subs	r2, #4
    8750:	f241 1311 	movw	r3, #4369	; 0x1111
    8754:	f2c1 1311 	movt	r3, #4369	; 0x1111
    8758:	6013      	str	r3, [r2, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) 0x10101010UL;				/* R10 */
    875a:	3a04      	subs	r2, #4
    875c:	f241 0310 	movw	r3, #4112	; 0x1010
    8760:	f2c1 0310 	movt	r3, #4112	; 0x1010
    8764:	6013      	str	r3, [r2, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) 0x09090909UL;				/* R09 */
    8766:	3a04      	subs	r2, #4
    8768:	f640 1309 	movw	r3, #2313	; 0x909
    876c:	f6c0 1309 	movt	r3, #2313	; 0x909
    8770:	6013      	str	r3, [r2, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) 0x08080808UL;				/* R08 */
    8772:	3a04      	subs	r2, #4
    8774:	f640 0308 	movw	r3, #2056	; 0x808
    8778:	f6c0 0308 	movt	r3, #2056	; 0x808
    877c:	6013      	str	r3, [r2, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) 0x07070707UL;				/* R07 */
    877e:	3a04      	subs	r2, #4
    8780:	f240 7307 	movw	r3, #1799	; 0x707
    8784:	f2c0 7307 	movt	r3, #1799	; 0x707
    8788:	6013      	str	r3, [r2, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) 0x06060606UL;				/* R06 */
    878a:	3a04      	subs	r2, #4
    878c:	f240 6306 	movw	r3, #1542	; 0x606
    8790:	f2c0 6306 	movt	r3, #1542	; 0x606
    8794:	6013      	str	r3, [r2, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) 0x05050505UL;				/* R05 */
    8796:	3a04      	subs	r2, #4
    8798:	f240 5305 	movw	r3, #1285	; 0x505
    879c:	f2c0 5305 	movt	r3, #1285	; 0x505
    87a0:	6013      	str	r3, [r2, #0]
		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) 0x04040404UL;				/* R04 */
    87a2:	3a04      	subs	r2, #4
    87a4:	f240 4304 	movw	r3, #1028	; 0x404
    87a8:	f2c0 4304 	movt	r3, #1028	; 0x404
    87ac:	6013      	str	r3, [r2, #0]
		pxTopOfStack--;
		*pxTopOfStack = portINITIAL_EXC_RETURN;						/* EXC_RETURN */
    87ae:	0003      	movs	r3, r0
    87b0:	3b44      	subs	r3, #68	; 0x44
    87b2:	2244      	movs	r2, #68	; 0x44
    87b4:	4252      	negs	r2, r2
    87b6:	601a      	str	r2, [r3, #0]
			}
		}
		#endif /* configENABLE_MPU */

		pxTopOfStack--;
		*pxTopOfStack = ( StackType_t ) pxEndOfStack;	/* Slot used to hold this task's PSPLIM value. */
    87b8:	3b04      	subs	r3, #4
    87ba:	6019      	str	r1, [r3, #0]

		#if( configENABLE_TRUSTZONE == 1 )
		{
			pxTopOfStack--;
			*pxTopOfStack = portNO_SECURE_CONTEXT;		/* Slot used to hold this task's xSecureContext value. */
    87bc:	384c      	subs	r0, #76	; 0x4c
    87be:	2300      	movs	r3, #0
    87c0:	6003      	str	r3, [r0, #0]
		#endif /* configENABLE_TRUSTZONE */
	}
	#endif /* portPRELOAD_REGISTERS */

	return pxTopOfStack;
}
    87c2:	bd30      	pop	{r4, r5, pc}

000087c4 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION */
{
    87c4:	b510      	push	{r4, lr}
	/* Make PendSV, CallSV and SysTick the same priority as the kernel. */
	*( portNVIC_SYSPRI2 ) |= portNVIC_PENDSV_PRI;
    87c6:	f64e 5320 	movw	r3, #60704	; 0xed20
    87ca:	f2ce 0300 	movt	r3, #57344	; 0xe000
    87ce:	6819      	ldr	r1, [r3, #0]
    87d0:	22ff      	movs	r2, #255	; 0xff
    87d2:	0412      	lsls	r2, r2, #16
    87d4:	430a      	orrs	r2, r1
    87d6:	601a      	str	r2, [r3, #0]
	*( portNVIC_SYSPRI2 ) |= portNVIC_SYSTICK_PRI;
    87d8:	6819      	ldr	r1, [r3, #0]
    87da:	22ff      	movs	r2, #255	; 0xff
    87dc:	0612      	lsls	r2, r2, #24
    87de:	430a      	orrs	r2, r1
    87e0:	601a      	str	r2, [r3, #0]
	}
	#endif /* configENABLE_MPU */

	/* Start the timer that generates the tick ISR. Interrupts are disabled
	 * here already. */
	vPortSetupTimerInterrupt();
    87e2:	f248 53c1 	movw	r3, #34241	; 0x85c1
    87e6:	f2c0 0300 	movt	r3, #0
    87ea:	4798      	blx	r3

	/* Initialize the critical nesting count ready for the first task. */
	ulCriticalNesting = 0;
    87ec:	f242 0304 	movw	r3, #8196	; 0x2004
    87f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    87f4:	2200      	movs	r2, #0
    87f6:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vStartFirstTask();
    87f8:	f648 0361 	movw	r3, #34913	; 0x8861
    87fc:	f2c0 0300 	movt	r3, #0
    8800:	4798      	blx	r3
	 * exit error function to prevent compiler warnings about a static function
	 * not being called in the case that the application writer overrides this
	 * functionality by defining configTASK_RETURN_ADDRESS. Call
	 * vTaskSwitchContext() so link time optimization does not remove the
	 * symbol. */
	vTaskSwitchContext();
    8802:	f249 0391 	movw	r3, #37009	; 0x9091
    8806:	f2c0 0300 	movt	r3, #0
    880a:	4798      	blx	r3
	prvTaskExitError();
    880c:	f248 539d 	movw	r3, #34205	; 0x859d
    8810:	f2c0 0300 	movt	r3, #0
    8814:	4798      	blx	r3

	/* Should not get here. */
	return 0;
}
    8816:	2000      	movs	r0, #0
    8818:	bd10      	pop	{r4, pc}
    881a:	0000      	movs	r0, r0
    881c:	0000      	movs	r0, r0
	...

00008820 <vRestoreContextOfFirstTask>:
	#error Cortex-M23 does not have a Floating Point Unit (FPU) and therefore configENABLE_FPU must be set to 0.
#endif

void vRestoreContextOfFirstTask( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
{
	__asm volatile
    8820:	4a0b      	ldr	r2, [pc, #44]	; (8850 <pxCurrentTCBConst2>)
    8822:	6813      	ldr	r3, [r2, #0]
    8824:	6818      	ldr	r0, [r3, #0]
    8826:	c80e      	ldmia	r0!, {r1, r2, r3}
    8828:	4c0a      	ldr	r4, [pc, #40]	; (8854 <xSecureContextConst2>)
    882a:	6021      	str	r1, [r4, #0]
    882c:	f382 880b 	msr	PSPLIM, r2
    8830:	2102      	movs	r1, #2
    8832:	f381 8814 	msr	CONTROL, r1
    8836:	3020      	adds	r0, #32
    8838:	f380 8809 	msr	PSP, r0
    883c:	f3bf 8f6f 	isb	sy
    8840:	4718      	bx	r3
    8842:	46c0      	nop			; (mov r8, r8)
    8844:	46c0      	nop			; (mov r8, r8)
    8846:	46c0      	nop			; (mov r8, r8)
    8848:	46c0      	nop			; (mov r8, r8)
    884a:	46c0      	nop			; (mov r8, r8)
    884c:	46c0      	nop			; (mov r8, r8)
    884e:	46c0      	nop			; (mov r8, r8)

00008850 <pxCurrentTCBConst2>:
    8850:	20003128 	.word	0x20003128

00008854 <xSecureContextConst2>:
    8854:	20003120 	.word	0x20003120
	...

00008860 <vStartFirstTask>:
}
/*-----------------------------------------------------------*/

void vStartFirstTask( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
{
	__asm volatile
    8860:	4807      	ldr	r0, [pc, #28]	; (8880 <xVTORConst>)
    8862:	6800      	ldr	r0, [r0, #0]
    8864:	6800      	ldr	r0, [r0, #0]
    8866:	f380 8808 	msr	MSP, r0
    886a:	b662      	cpsie	i
    886c:	f3bf 8f4f 	dsb	sy
    8870:	f3bf 8f6f 	isb	sy
    8874:	df02      	svc	2
    8876:	46c0      	nop			; (mov r8, r8)
    8878:	46c0      	nop			; (mov r8, r8)
    887a:	46c0      	nop			; (mov r8, r8)
    887c:	46c0      	nop			; (mov r8, r8)
    887e:	46c0      	nop			; (mov r8, r8)

00008880 <xVTORConst>:
    8880:	e000ed08 	.word	0xe000ed08

00008884 <ulSetInterruptMask>:
}
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMask( void ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */
{
	__asm volatile
    8884:	f3ef 8010 	mrs	r0, PRIMASK
    8888:	b672      	cpsid	i
    888a:	4770      	bx	lr

0000888c <vClearInterruptMask>:
}
/*-----------------------------------------------------------*/

void vClearInterruptMask( __attribute__( ( unused ) ) uint32_t ulMask ) /* __attribute__(( naked )) PRIVILEGED_FUNCTION */
{
	__asm volatile
    888c:	f380 8810 	msr	PRIMASK, r0
    8890:	4770      	bx	lr
	...

000088a0 <PendSV_Handler>:
}
/*-----------------------------------------------------------*/

void PendSV_Handler( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
{
	__asm volatile
    88a0:	f3ef 8109 	mrs	r1, PSP
    88a4:	4a23      	ldr	r2, [pc, #140]	; (8934 <xSecureContextConst>)
    88a6:	6810      	ldr	r0, [r2, #0]
    88a8:	b178      	cbz	r0, 88ca <save_ns_context>
    88aa:	b507      	push	{r0, r1, r2, lr}
    88ac:	f7ff f9c4 	bl	7c38 <SecureContext_SaveContext>
    88b0:	bc0f      	pop	{r0, r1, r2, r3}
    88b2:	469e      	mov	lr, r3
    88b4:	065a      	lsls	r2, r3, #25
    88b6:	d508      	bpl.n	88ca <save_ns_context>
    88b8:	4b1d      	ldr	r3, [pc, #116]	; (8930 <pxCurrentTCBConst>)
    88ba:	681a      	ldr	r2, [r3, #0]
    88bc:	390c      	subs	r1, #12
    88be:	6011      	str	r1, [r2, #0]
    88c0:	f3ef 820b 	mrs	r2, PSPLIM
    88c4:	4673      	mov	r3, lr
    88c6:	c10d      	stmia	r1!, {r0, r2, r3}
    88c8:	e00c      	b.n	88e4 <select_next_task>

000088ca <save_ns_context>:
    88ca:	4b19      	ldr	r3, [pc, #100]	; (8930 <pxCurrentTCBConst>)
    88cc:	681a      	ldr	r2, [r3, #0]
    88ce:	392c      	subs	r1, #44	; 0x2c
    88d0:	6011      	str	r1, [r2, #0]
    88d2:	f3ef 820b 	mrs	r2, PSPLIM
    88d6:	4673      	mov	r3, lr
    88d8:	c1fd      	stmia	r1!, {r0, r2, r3, r4, r5, r6, r7}
    88da:	4644      	mov	r4, r8
    88dc:	464d      	mov	r5, r9
    88de:	4656      	mov	r6, sl
    88e0:	465f      	mov	r7, fp
    88e2:	c1f0      	stmia	r1!, {r4, r5, r6, r7}

000088e4 <select_next_task>:
    88e4:	b672      	cpsid	i
    88e6:	f000 fbd3 	bl	9090 <vTaskSwitchContext>
    88ea:	b662      	cpsie	i
    88ec:	4a10      	ldr	r2, [pc, #64]	; (8930 <pxCurrentTCBConst>)
    88ee:	6813      	ldr	r3, [r2, #0]
    88f0:	6819      	ldr	r1, [r3, #0]
    88f2:	c90d      	ldmia	r1!, {r0, r2, r3}
    88f4:	f382 880b 	msr	PSPLIM, r2
    88f8:	469e      	mov	lr, r3
    88fa:	4a0e      	ldr	r2, [pc, #56]	; (8934 <xSecureContextConst>)
    88fc:	6010      	str	r0, [r2, #0]
    88fe:	b148      	cbz	r0, 8914 <restore_ns_context>
    8900:	b40a      	push	{r1, r3}
    8902:	f7ff f995 	bl	7c30 <SecureContext_LoadContext>
    8906:	bc0a      	pop	{r1, r3}
    8908:	469e      	mov	lr, r3
    890a:	065a      	lsls	r2, r3, #25
    890c:	d502      	bpl.n	8914 <restore_ns_context>
    890e:	f381 8809 	msr	PSP, r1
    8912:	4770      	bx	lr

00008914 <restore_ns_context>:
    8914:	3110      	adds	r1, #16
    8916:	c9f0      	ldmia	r1!, {r4, r5, r6, r7}
    8918:	46a0      	mov	r8, r4
    891a:	46a9      	mov	r9, r5
    891c:	46b2      	mov	sl, r6
    891e:	46bb      	mov	fp, r7
    8920:	f381 8809 	msr	PSP, r1
    8924:	3920      	subs	r1, #32
    8926:	c9f0      	ldmia	r1!, {r4, r5, r6, r7}
    8928:	4770      	bx	lr
    892a:	46c0      	nop			; (mov r8, r8)
    892c:	46c0      	nop			; (mov r8, r8)
    892e:	46c0      	nop			; (mov r8, r8)

00008930 <pxCurrentTCBConst>:
    8930:	20003128 	.word	0x20003128

00008934 <xSecureContextConst>:
    8934:	20003120 	.word	0x20003120
	...

00008940 <SVCall_Handler>:
}
/*-----------------------------------------------------------*/

void SVCall_Handler( void ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
{
	__asm volatile
    8940:	2004      	movs	r0, #4
    8942:	4671      	mov	r1, lr
    8944:	4208      	tst	r0, r1
    8946:	d003      	beq.n	8950 <stacking_used_msp>
    8948:	f3ef 8009 	mrs	r0, PSP
    894c:	4a04      	ldr	r2, [pc, #16]	; (8960 <svchandler_address_const>)
    894e:	4710      	bx	r2

00008950 <stacking_used_msp>:
    8950:	f3ef 8008 	mrs	r0, MSP
    8954:	4a02      	ldr	r2, [pc, #8]	; (8960 <svchandler_address_const>)
    8956:	4710      	bx	r2
    8958:	46c0      	nop			; (mov r8, r8)
    895a:	46c0      	nop			; (mov r8, r8)
    895c:	46c0      	nop			; (mov r8, r8)
    895e:	46c0      	nop			; (mov r8, r8)

00008960 <svchandler_address_const>:
    8960:	00008687 	.word	0x00008687

00008964 <vPortAllocateSecureContext>:
}
/*-----------------------------------------------------------*/

void vPortAllocateSecureContext( uint32_t ulSecureStackSize ) /* __attribute__ (( naked )) */
{
	__asm volatile
    8964:	df00      	svc	0
    8966:	4770      	bx	lr

00008968 <vPortFreeSecureContext>:
}
/*-----------------------------------------------------------*/

void vPortFreeSecureContext( uint32_t *pulTCB ) /* __attribute__ (( naked )) PRIVILEGED_FUNCTION */
{
	__asm volatile
    8968:	6801      	ldr	r1, [r0, #0]
    896a:	6808      	ldr	r0, [r1, #0]
    896c:	2800      	cmp	r0, #0
    896e:	d000      	beq.n	8972 <free_secure_context>
    8970:	4770      	bx	lr

00008972 <free_secure_context>:
    8972:	df01      	svc	1
    8974:	4770      	bx	lr

00008976 <prvGetExpectedIdleTime>:
		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
		task that are in the Ready state, even though the idle task is
		running. */
		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
		{
			if( uxTopReadyPriority > tskIDLE_PRIORITY )
    8976:	f243 1324 	movw	r3, #12580	; 0x3124
    897a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    897e:	681a      	ldr	r2, [r3, #0]
				uxHigherPriorityReadyTasks = pdTRUE;
			}
		}
		#endif

		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
    8980:	685b      	ldr	r3, [r3, #4]
    8982:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		{
			xReturn = 0;
    8984:	2000      	movs	r0, #0
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
    8986:	b933      	cbnz	r3, 8996 <prvGetExpectedIdleTime+0x20>
		}
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
    8988:	f243 1324 	movw	r3, #12580	; 0x3124
    898c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8990:	689b      	ldr	r3, [r3, #8]
    8992:	2b01      	cmp	r3, #1
    8994:	d900      	bls.n	8998 <prvGetExpectedIdleTime+0x22>
		{
			xReturn = xNextTaskUnblockTime - xTickCount;
		}

		return xReturn;
	}
    8996:	4770      	bx	lr
		else if( uxHigherPriorityReadyTasks != pdFALSE )
    8998:	2a00      	cmp	r2, #0
    899a:	d1fc      	bne.n	8996 <prvGetExpectedIdleTime+0x20>
			xReturn = xNextTaskUnblockTime - xTickCount;
    899c:	f243 1324 	movw	r3, #12580	; 0x3124
    89a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    89a4:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
    89a6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    89a8:	1ac0      	subs	r0, r0, r3
    89aa:	e7f4      	b.n	8996 <prvGetExpectedIdleTime+0x20>

000089ac <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    89ac:	f243 1324 	movw	r3, #12580	; 0x3124
    89b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    89b4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    89b6:	681b      	ldr	r3, [r3, #0]
    89b8:	b14b      	cbz	r3, 89ce <prvResetNextTaskUnblockTime+0x22>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    89ba:	f243 1324 	movw	r3, #12580	; 0x3124
    89be:	f2c2 0300 	movt	r3, #8192	; 0x2000
    89c2:	6f5a      	ldr	r2, [r3, #116]	; 0x74
    89c4:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    89c6:	68d2      	ldr	r2, [r2, #12]
    89c8:	6852      	ldr	r2, [r2, #4]
    89ca:	66da      	str	r2, [r3, #108]	; 0x6c
	}
}
    89cc:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
    89ce:	f243 1324 	movw	r3, #12580	; 0x3124
    89d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    89d6:	2201      	movs	r2, #1
    89d8:	4252      	negs	r2, r2
    89da:	66da      	str	r2, [r3, #108]	; 0x6c
    89dc:	e7f6      	b.n	89cc <prvResetNextTaskUnblockTime+0x20>

000089de <prvInitialiseNewTask>:
{
    89de:	b5f0      	push	{r4, r5, r6, r7, lr}
    89e0:	46d6      	mov	lr, sl
    89e2:	b500      	push	{lr}
    89e4:	b082      	sub	sp, #8
    89e6:	9000      	str	r0, [sp, #0]
    89e8:	000f      	movs	r7, r1
    89ea:	9301      	str	r3, [sp, #4]
    89ec:	9e0a      	ldr	r6, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    89ee:	0094      	lsls	r4, r2, #2
    89f0:	0022      	movs	r2, r4
    89f2:	21a5      	movs	r1, #165	; 0xa5
    89f4:	6b30      	ldr	r0, [r6, #48]	; 0x30
    89f6:	f249 13f9 	movw	r3, #37369	; 0x91f9
    89fa:	f2c0 0300 	movt	r3, #0
    89fe:	4798      	blx	r3
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    8a00:	1f22      	subs	r2, r4, #4
    8a02:	6b33      	ldr	r3, [r6, #48]	; 0x30
    8a04:	469c      	mov	ip, r3
    8a06:	4462      	add	r2, ip
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
    8a08:	2307      	movs	r3, #7
    8a0a:	439a      	bics	r2, r3
    8a0c:	0015      	movs	r5, r2
	if( pcName != NULL )
    8a0e:	2f00      	cmp	r7, #0
    8a10:	d03e      	beq.n	8a90 <prvInitialiseNewTask+0xb2>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    8a12:	783a      	ldrb	r2, [r7, #0]
    8a14:	332d      	adds	r3, #45	; 0x2d
    8a16:	54f2      	strb	r2, [r6, r3]
			if( pcName[ x ] == ( char ) 0x00 )
    8a18:	783b      	ldrb	r3, [r7, #0]
    8a1a:	b163      	cbz	r3, 8a36 <prvInitialiseNewTask+0x58>
    8a1c:	3701      	adds	r7, #1
    8a1e:	0033      	movs	r3, r6
    8a20:	3335      	adds	r3, #53	; 0x35
    8a22:	0030      	movs	r0, r6
    8a24:	3040      	adds	r0, #64	; 0x40
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    8a26:	783a      	ldrb	r2, [r7, #0]
    8a28:	701a      	strb	r2, [r3, #0]
			if( pcName[ x ] == ( char ) 0x00 )
    8a2a:	783a      	ldrb	r2, [r7, #0]
    8a2c:	b11a      	cbz	r2, 8a36 <prvInitialiseNewTask+0x58>
    8a2e:	3701      	adds	r7, #1
    8a30:	3301      	adds	r3, #1
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    8a32:	4283      	cmp	r3, r0
    8a34:	d1f7      	bne.n	8a26 <prvInitialiseNewTask+0x48>
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    8a36:	2200      	movs	r2, #0
    8a38:	233f      	movs	r3, #63	; 0x3f
    8a3a:	54f2      	strb	r2, [r6, r3]
    8a3c:	9f08      	ldr	r7, [sp, #32]
    8a3e:	2f04      	cmp	r7, #4
    8a40:	d900      	bls.n	8a44 <prvInitialiseNewTask+0x66>
    8a42:	2704      	movs	r7, #4
	pxNewTCB->uxPriority = uxPriority;
    8a44:	62f7      	str	r7, [r6, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
    8a46:	64b7      	str	r7, [r6, #72]	; 0x48
		pxNewTCB->uxMutexesHeld = 0;
    8a48:	2400      	movs	r4, #0
    8a4a:	64f4      	str	r4, [r6, #76]	; 0x4c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    8a4c:	1d30      	adds	r0, r6, #4
    8a4e:	f248 4ab1 	movw	sl, #33969	; 0x84b1
    8a52:	f2c0 0a00 	movt	sl, #0
    8a56:	47d0      	blx	sl
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    8a58:	0030      	movs	r0, r6
    8a5a:	3018      	adds	r0, #24
    8a5c:	47d0      	blx	sl
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    8a5e:	6136      	str	r6, [r6, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    8a60:	2305      	movs	r3, #5
    8a62:	1bdf      	subs	r7, r3, r7
    8a64:	61b7      	str	r7, [r6, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    8a66:	6276      	str	r6, [r6, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
    8a68:	6534      	str	r4, [r6, #80]	; 0x50
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    8a6a:	334f      	adds	r3, #79	; 0x4f
    8a6c:	54f4      	strb	r4, [r6, r3]
				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters );
    8a6e:	9b01      	ldr	r3, [sp, #4]
    8a70:	9a00      	ldr	r2, [sp, #0]
    8a72:	6b31      	ldr	r1, [r6, #48]	; 0x30
    8a74:	0028      	movs	r0, r5
    8a76:	f248 65ff 	movw	r5, #34559	; 0x86ff
    8a7a:	f2c0 0500 	movt	r5, #0
    8a7e:	47a8      	blx	r5
    8a80:	6030      	str	r0, [r6, #0]
	if( pxCreatedTask != NULL )
    8a82:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8a84:	b103      	cbz	r3, 8a88 <prvInitialiseNewTask+0xaa>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    8a86:	601e      	str	r6, [r3, #0]
}
    8a88:	b002      	add	sp, #8
    8a8a:	bc04      	pop	{r2}
    8a8c:	4692      	mov	sl, r2
    8a8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    8a90:	2200      	movs	r2, #0
    8a92:	2334      	movs	r3, #52	; 0x34
    8a94:	54f2      	strb	r2, [r6, r3]
    8a96:	e7d1      	b.n	8a3c <prvInitialiseNewTask+0x5e>

00008a98 <prvAddNewTaskToReadyList>:
{
    8a98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8a9a:	46ce      	mov	lr, r9
    8a9c:	4647      	mov	r7, r8
    8a9e:	b580      	push	{r7, lr}
    8aa0:	0004      	movs	r4, r0
	taskENTER_CRITICAL();
    8aa2:	f248 6311 	movw	r3, #34321	; 0x8611
    8aa6:	f2c0 0300 	movt	r3, #0
    8aaa:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
    8aac:	f243 1324 	movw	r3, #12580	; 0x3124
    8ab0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8ab4:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    8ab6:	3201      	adds	r2, #1
    8ab8:	679a      	str	r2, [r3, #120]	; 0x78
		if( pxCurrentTCB == NULL )
    8aba:	685b      	ldr	r3, [r3, #4]
    8abc:	2b00      	cmp	r3, #0
    8abe:	d04f      	beq.n	8b60 <prvAddNewTaskToReadyList+0xc8>
			if( xSchedulerRunning == pdFALSE )
    8ac0:	f243 13a4 	movw	r3, #12708	; 0x31a4
    8ac4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8ac8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    8aca:	b96b      	cbnz	r3, 8ae8 <prvAddNewTaskToReadyList+0x50>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    8acc:	f243 1324 	movw	r3, #12580	; 0x3124
    8ad0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8ad4:	685b      	ldr	r3, [r3, #4]
    8ad6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8ad8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    8ada:	4293      	cmp	r3, r2
    8adc:	d804      	bhi.n	8ae8 <prvAddNewTaskToReadyList+0x50>
					pxCurrentTCB = pxNewTCB;
    8ade:	f243 1324 	movw	r3, #12580	; 0x3124
    8ae2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8ae6:	605c      	str	r4, [r3, #4]
		uxTaskNumber++;
    8ae8:	f243 12a4 	movw	r2, #12708	; 0x31a4
    8aec:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8af0:	6e93      	ldr	r3, [r2, #104]	; 0x68
    8af2:	3301      	adds	r3, #1
    8af4:	6693      	str	r3, [r2, #104]	; 0x68
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    8af6:	6423      	str	r3, [r4, #64]	; 0x40
		prvAddTaskToReadyList( pxNewTCB );
    8af8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    8afa:	f243 1324 	movw	r3, #12580	; 0x3124
    8afe:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b02:	681b      	ldr	r3, [r3, #0]
    8b04:	429a      	cmp	r2, r3
    8b06:	d904      	bls.n	8b12 <prvAddNewTaskToReadyList+0x7a>
    8b08:	f243 1324 	movw	r3, #12580	; 0x3124
    8b0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b10:	601a      	str	r2, [r3, #0]
    8b12:	1d21      	adds	r1, r4, #4
    8b14:	f243 1024 	movw	r0, #12580	; 0x3124
    8b18:	f2c2 0000 	movt	r0, #8192	; 0x2000
    8b1c:	3008      	adds	r0, #8
    8b1e:	0093      	lsls	r3, r2, #2
    8b20:	189b      	adds	r3, r3, r2
    8b22:	009b      	lsls	r3, r3, #2
    8b24:	18c0      	adds	r0, r0, r3
    8b26:	f248 43b7 	movw	r3, #33975	; 0x84b7
    8b2a:	f2c0 0300 	movt	r3, #0
    8b2e:	4798      	blx	r3
	taskEXIT_CRITICAL();
    8b30:	f248 632b 	movw	r3, #34347	; 0x862b
    8b34:	f2c0 0300 	movt	r3, #0
    8b38:	4798      	blx	r3
	if( xSchedulerRunning != pdFALSE )
    8b3a:	f243 13a4 	movw	r3, #12708	; 0x31a4
    8b3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b42:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    8b44:	b143      	cbz	r3, 8b58 <prvAddNewTaskToReadyList+0xc0>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    8b46:	f243 1324 	movw	r3, #12580	; 0x3124
    8b4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b4e:	685b      	ldr	r3, [r3, #4]
    8b50:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    8b52:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    8b54:	429a      	cmp	r2, r3
    8b56:	d33e      	bcc.n	8bd6 <prvAddNewTaskToReadyList+0x13e>
}
    8b58:	bc0c      	pop	{r2, r3}
    8b5a:	4690      	mov	r8, r2
    8b5c:	4699      	mov	r9, r3
    8b5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			pxCurrentTCB = pxNewTCB;
    8b60:	f243 1324 	movw	r3, #12580	; 0x3124
    8b64:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8b68:	605c      	str	r4, [r3, #4]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    8b6a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    8b6c:	2b01      	cmp	r3, #1
    8b6e:	d1bb      	bne.n	8ae8 <prvAddNewTaskToReadyList+0x50>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    8b70:	f243 1624 	movw	r6, #12580	; 0x3124
    8b74:	f2c2 0600 	movt	r6, #8192	; 0x2000
    8b78:	0030      	movs	r0, r6
    8b7a:	3008      	adds	r0, #8
    8b7c:	f248 459b 	movw	r5, #33947	; 0x849b
    8b80:	f2c0 0500 	movt	r5, #0
    8b84:	47a8      	blx	r5
    8b86:	0030      	movs	r0, r6
    8b88:	301c      	adds	r0, #28
    8b8a:	47a8      	blx	r5
    8b8c:	0030      	movs	r0, r6
    8b8e:	3030      	adds	r0, #48	; 0x30
    8b90:	47a8      	blx	r5
    8b92:	0030      	movs	r0, r6
    8b94:	3044      	adds	r0, #68	; 0x44
    8b96:	47a8      	blx	r5
    8b98:	0030      	movs	r0, r6
    8b9a:	3058      	adds	r0, #88	; 0x58
    8b9c:	47a8      	blx	r5
	vListInitialise( &xDelayedTaskList1 );
    8b9e:	f240 097c 	movw	r9, #124	; 0x7c
    8ba2:	44b1      	add	r9, r6
    8ba4:	4648      	mov	r0, r9
    8ba6:	47a8      	blx	r5
	vListInitialise( &xDelayedTaskList2 );
    8ba8:	f243 17a4 	movw	r7, #12708	; 0x31a4
    8bac:	f2c2 0700 	movt	r7, #8192	; 0x2000
    8bb0:	f240 0810 	movw	r8, #16
    8bb4:	44b8      	add	r8, r7
    8bb6:	4640      	mov	r0, r8
    8bb8:	47a8      	blx	r5
	vListInitialise( &xPendingReadyList );
    8bba:	0038      	movs	r0, r7
    8bbc:	3024      	adds	r0, #36	; 0x24
    8bbe:	47a8      	blx	r5
		vListInitialise( &xTasksWaitingTermination );
    8bc0:	0038      	movs	r0, r7
    8bc2:	3038      	adds	r0, #56	; 0x38
    8bc4:	47a8      	blx	r5
		vListInitialise( &xSuspendedTaskList );
    8bc6:	0038      	movs	r0, r7
    8bc8:	304c      	adds	r0, #76	; 0x4c
    8bca:	47a8      	blx	r5
	pxDelayedTaskList = &xDelayedTaskList1;
    8bcc:	464b      	mov	r3, r9
    8bce:	6773      	str	r3, [r6, #116]	; 0x74
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    8bd0:	4643      	mov	r3, r8
    8bd2:	663b      	str	r3, [r7, #96]	; 0x60
    8bd4:	e788      	b.n	8ae8 <prvAddNewTaskToReadyList+0x50>
			taskYIELD_IF_USING_PREEMPTION();
    8bd6:	f248 53f9 	movw	r3, #34297	; 0x85f9
    8bda:	f2c0 0300 	movt	r3, #0
    8bde:	4798      	blx	r3
}
    8be0:	e7ba      	b.n	8b58 <prvAddNewTaskToReadyList+0xc0>

00008be2 <prvDeleteTCB>:
	{
    8be2:	b570      	push	{r4, r5, r6, lr}
    8be4:	0004      	movs	r4, r0
		portCLEAN_UP_TCB( pxTCB );
    8be6:	f648 1369 	movw	r3, #35177	; 0x8969
    8bea:	f2c0 0300 	movt	r3, #0
    8bee:	4798      	blx	r3
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
    8bf0:	2355      	movs	r3, #85	; 0x55
    8bf2:	5ce3      	ldrb	r3, [r4, r3]
    8bf4:	b12b      	cbz	r3, 8c02 <prvDeleteTCB+0x20>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
    8bf6:	2b01      	cmp	r3, #1
    8bf8:	d00c      	beq.n	8c14 <prvDeleteTCB+0x32>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
    8bfa:	2b02      	cmp	r3, #2
    8bfc:	d009      	beq.n	8c12 <prvDeleteTCB+0x30>
    8bfe:	b672      	cpsid	i
    8c00:	e7fe      	b.n	8c00 <prvDeleteTCB+0x1e>
				vPortFree( pxTCB->pxStack );
    8c02:	6b20      	ldr	r0, [r4, #48]	; 0x30
    8c04:	f248 4513 	movw	r5, #33811	; 0x8413
    8c08:	f2c0 0500 	movt	r5, #0
    8c0c:	47a8      	blx	r5
				vPortFree( pxTCB );
    8c0e:	0020      	movs	r0, r4
    8c10:	47a8      	blx	r5
	}
    8c12:	bd70      	pop	{r4, r5, r6, pc}
				vPortFree( pxTCB );
    8c14:	0020      	movs	r0, r4
    8c16:	f248 4313 	movw	r3, #33811	; 0x8413
    8c1a:	f2c0 0300 	movt	r3, #0
    8c1e:	4798      	blx	r3
    8c20:	e7f7      	b.n	8c12 <prvDeleteTCB+0x30>

00008c22 <xTaskCreateStatic>:
	{
    8c22:	b570      	push	{r4, r5, r6, lr}
    8c24:	b086      	sub	sp, #24
    8c26:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    8c28:	9c0c      	ldr	r4, [sp, #48]	; 0x30
		configASSERT( puxStackBuffer != NULL );
    8c2a:	b13d      	cbz	r5, 8c3c <xTaskCreateStatic+0x1a>
		configASSERT( pxTaskBuffer != NULL );
    8c2c:	b144      	cbz	r4, 8c40 <xTaskCreateStatic+0x1e>
			volatile size_t xSize = sizeof( StaticTask_t );
    8c2e:	2658      	movs	r6, #88	; 0x58
    8c30:	9604      	str	r6, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
    8c32:	9e04      	ldr	r6, [sp, #16]
    8c34:	2e58      	cmp	r6, #88	; 0x58
    8c36:	d005      	beq.n	8c44 <xTaskCreateStatic+0x22>
    8c38:	b672      	cpsid	i
    8c3a:	e7fe      	b.n	8c3a <xTaskCreateStatic+0x18>
		configASSERT( puxStackBuffer != NULL );
    8c3c:	b672      	cpsid	i
    8c3e:	e7fe      	b.n	8c3e <xTaskCreateStatic+0x1c>
		configASSERT( pxTaskBuffer != NULL );
    8c40:	b672      	cpsid	i
    8c42:	e7fe      	b.n	8c42 <xTaskCreateStatic+0x20>
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
    8c44:	9e04      	ldr	r6, [sp, #16]
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
    8c46:	6325      	str	r5, [r4, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
    8c48:	2602      	movs	r6, #2
    8c4a:	2555      	movs	r5, #85	; 0x55
    8c4c:	5566      	strb	r6, [r4, r5]
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
    8c4e:	2500      	movs	r5, #0
    8c50:	9503      	str	r5, [sp, #12]
    8c52:	9402      	str	r4, [sp, #8]
    8c54:	ad05      	add	r5, sp, #20
    8c56:	9501      	str	r5, [sp, #4]
    8c58:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    8c5a:	9500      	str	r5, [sp, #0]
    8c5c:	f648 15df 	movw	r5, #35295	; 0x89df
    8c60:	f2c0 0500 	movt	r5, #0
    8c64:	47a8      	blx	r5
			prvAddNewTaskToReadyList( pxNewTCB );
    8c66:	0020      	movs	r0, r4
    8c68:	f648 2399 	movw	r3, #35481	; 0x8a99
    8c6c:	f2c0 0300 	movt	r3, #0
    8c70:	4798      	blx	r3
	}
    8c72:	9805      	ldr	r0, [sp, #20]
    8c74:	b006      	add	sp, #24
    8c76:	bd70      	pop	{r4, r5, r6, pc}

00008c78 <xTaskCreate>:
	{
    8c78:	b5f0      	push	{r4, r5, r6, r7, lr}
    8c7a:	b087      	sub	sp, #28
    8c7c:	9004      	str	r0, [sp, #16]
    8c7e:	9105      	str	r1, [sp, #20]
    8c80:	0014      	movs	r4, r2
    8c82:	001f      	movs	r7, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    8c84:	0090      	lsls	r0, r2, #2
    8c86:	f248 23b3 	movw	r3, #33459	; 0x82b3
    8c8a:	f2c0 0300 	movt	r3, #0
    8c8e:	4798      	blx	r3
    8c90:	0005      	movs	r5, r0
			if( pxStack != NULL )
    8c92:	b348      	cbz	r0, 8ce8 <xTaskCreate+0x70>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    8c94:	2058      	movs	r0, #88	; 0x58
    8c96:	f248 23b3 	movw	r3, #33459	; 0x82b3
    8c9a:	f2c0 0300 	movt	r3, #0
    8c9e:	4798      	blx	r3
    8ca0:	0006      	movs	r6, r0
				if( pxNewTCB != NULL )
    8ca2:	b1d8      	cbz	r0, 8cdc <xTaskCreate+0x64>
					pxNewTCB->pxStack = pxStack;
    8ca4:	6305      	str	r5, [r0, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
    8ca6:	2300      	movs	r3, #0
    8ca8:	2255      	movs	r2, #85	; 0x55
    8caa:	5483      	strb	r3, [r0, r2]
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    8cac:	9303      	str	r3, [sp, #12]
    8cae:	9002      	str	r0, [sp, #8]
    8cb0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    8cb2:	9301      	str	r3, [sp, #4]
    8cb4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    8cb6:	9300      	str	r3, [sp, #0]
    8cb8:	003b      	movs	r3, r7
    8cba:	0022      	movs	r2, r4
    8cbc:	9905      	ldr	r1, [sp, #20]
    8cbe:	9804      	ldr	r0, [sp, #16]
    8cc0:	f648 14df 	movw	r4, #35295	; 0x89df
    8cc4:	f2c0 0400 	movt	r4, #0
    8cc8:	47a0      	blx	r4
			prvAddNewTaskToReadyList( pxNewTCB );
    8cca:	0030      	movs	r0, r6
    8ccc:	f648 2399 	movw	r3, #35481	; 0x8a99
    8cd0:	f2c0 0300 	movt	r3, #0
    8cd4:	4798      	blx	r3
			xReturn = pdPASS;
    8cd6:	2001      	movs	r0, #1
	}
    8cd8:	b007      	add	sp, #28
    8cda:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
    8cdc:	0028      	movs	r0, r5
    8cde:	f248 4313 	movw	r3, #33811	; 0x8413
    8ce2:	f2c0 0300 	movt	r3, #0
    8ce6:	4798      	blx	r3
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    8ce8:	2001      	movs	r0, #1
    8cea:	4240      	negs	r0, r0
    8cec:	e7f4      	b.n	8cd8 <xTaskCreate+0x60>

00008cee <vTaskStartScheduler>:
{
    8cee:	b510      	push	{r4, lr}
    8cf0:	b088      	sub	sp, #32
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
    8cf2:	2400      	movs	r4, #0
    8cf4:	9405      	str	r4, [sp, #20]
		StackType_t *pxIdleTaskStackBuffer = NULL;
    8cf6:	9406      	str	r4, [sp, #24]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
    8cf8:	aa07      	add	r2, sp, #28
    8cfa:	a906      	add	r1, sp, #24
    8cfc:	a805      	add	r0, sp, #20
    8cfe:	f248 5389 	movw	r3, #34185	; 0x8589
    8d02:	f2c0 0300 	movt	r3, #0
    8d06:	4798      	blx	r3
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
    8d08:	f249 2124 	movw	r1, #37412	; 0x9224
    8d0c:	f2c0 0100 	movt	r1, #0
    8d10:	f648 70d1 	movw	r0, #36817	; 0x8fd1
    8d14:	f2c0 0000 	movt	r0, #0
    8d18:	9b05      	ldr	r3, [sp, #20]
    8d1a:	9302      	str	r3, [sp, #8]
    8d1c:	9b06      	ldr	r3, [sp, #24]
    8d1e:	9301      	str	r3, [sp, #4]
    8d20:	9400      	str	r4, [sp, #0]
    8d22:	2300      	movs	r3, #0
    8d24:	9a07      	ldr	r2, [sp, #28]
    8d26:	f648 4423 	movw	r4, #35875	; 0x8c23
    8d2a:	f2c0 0400 	movt	r4, #0
    8d2e:	47a0      	blx	r4
	if( xReturn == pdPASS )
    8d30:	b908      	cbnz	r0, 8d36 <vTaskStartScheduler+0x48>
}
    8d32:	b008      	add	sp, #32
    8d34:	bd10      	pop	{r4, pc}
		portDISABLE_INTERRUPTS();
    8d36:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
    8d38:	f243 1324 	movw	r3, #12580	; 0x3124
    8d3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d40:	2201      	movs	r2, #1
    8d42:	4252      	negs	r2, r2
    8d44:	66da      	str	r2, [r3, #108]	; 0x6c
		xSchedulerRunning = pdTRUE;
    8d46:	f243 12a4 	movw	r2, #12708	; 0x31a4
    8d4a:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8d4e:	2101      	movs	r1, #1
    8d50:	6651      	str	r1, [r2, #100]	; 0x64
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    8d52:	2200      	movs	r2, #0
    8d54:	671a      	str	r2, [r3, #112]	; 0x70
		if( xPortStartScheduler() != pdFALSE )
    8d56:	f248 73c5 	movw	r3, #34757	; 0x87c5
    8d5a:	f2c0 0300 	movt	r3, #0
    8d5e:	4798      	blx	r3
}
    8d60:	e7e7      	b.n	8d32 <vTaskStartScheduler+0x44>

00008d62 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    8d62:	f243 13a4 	movw	r3, #12708	; 0x31a4
    8d66:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d6a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    8d6c:	3201      	adds	r2, #1
    8d6e:	671a      	str	r2, [r3, #112]	; 0x70
}
    8d70:	4770      	bx	lr

00008d72 <xTaskIncrementTick>:
{
    8d72:	b5f0      	push	{r4, r5, r6, r7, lr}
    8d74:	46d6      	mov	lr, sl
    8d76:	464f      	mov	r7, r9
    8d78:	b580      	push	{r7, lr}
    8d7a:	b083      	sub	sp, #12
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    8d7c:	f243 13a4 	movw	r3, #12708	; 0x31a4
    8d80:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d84:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    8d86:	2b00      	cmp	r3, #0
    8d88:	d000      	beq.n	8d8c <xTaskIncrementTick+0x1a>
    8d8a:	e088      	b.n	8e9e <xTaskIncrementTick+0x12c>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    8d8c:	f243 1324 	movw	r3, #12580	; 0x3124
    8d90:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8d94:	6f1f      	ldr	r7, [r3, #112]	; 0x70
    8d96:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
    8d98:	671f      	str	r7, [r3, #112]	; 0x70
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    8d9a:	b9e7      	cbnz	r7, 8dd6 <xTaskIncrementTick+0x64>
			taskSWITCH_DELAYED_LISTS();
    8d9c:	f243 1324 	movw	r3, #12580	; 0x3124
    8da0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8da4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    8da6:	681b      	ldr	r3, [r3, #0]
    8da8:	b10b      	cbz	r3, 8dae <xTaskIncrementTick+0x3c>
    8daa:	b672      	cpsid	i
    8dac:	e7fe      	b.n	8dac <xTaskIncrementTick+0x3a>
    8dae:	f243 1224 	movw	r2, #12580	; 0x3124
    8db2:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8db6:	6f51      	ldr	r1, [r2, #116]	; 0x74
    8db8:	f243 13a4 	movw	r3, #12708	; 0x31a4
    8dbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8dc0:	6e18      	ldr	r0, [r3, #96]	; 0x60
    8dc2:	6750      	str	r0, [r2, #116]	; 0x74
    8dc4:	6619      	str	r1, [r3, #96]	; 0x60
    8dc6:	6f5a      	ldr	r2, [r3, #116]	; 0x74
    8dc8:	3201      	adds	r2, #1
    8dca:	675a      	str	r2, [r3, #116]	; 0x74
    8dcc:	f648 13ad 	movw	r3, #35245	; 0x89ad
    8dd0:	f2c0 0300 	movt	r3, #0
    8dd4:	4798      	blx	r3
		if( xConstTickCount >= xNextTaskUnblockTime )
    8dd6:	f243 1324 	movw	r3, #12580	; 0x3124
    8dda:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8dde:	6edb      	ldr	r3, [r3, #108]	; 0x6c
BaseType_t xSwitchRequired = pdFALSE;
    8de0:	2500      	movs	r5, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
    8de2:	429f      	cmp	r7, r3
    8de4:	d33a      	bcc.n	8e5c <xTaskIncrementTick+0xea>
    8de6:	2500      	movs	r5, #0
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    8de8:	f243 1424 	movw	r4, #12580	; 0x3124
    8dec:	f2c2 0400 	movt	r4, #8192	; 0x2000
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    8df0:	f248 49cf 	movw	r9, #33999	; 0x84cf
    8df4:	f2c0 0900 	movt	r9, #0
					prvAddTaskToReadyList( pxTCB );
    8df8:	f240 0a08 	movw	sl, #8
    8dfc:	44a2      	add	sl, r4
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    8dfe:	6f63      	ldr	r3, [r4, #116]	; 0x74
    8e00:	681b      	ldr	r3, [r3, #0]
    8e02:	b323      	cbz	r3, 8e4e <xTaskIncrementTick+0xdc>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    8e04:	6f63      	ldr	r3, [r4, #116]	; 0x74
    8e06:	68db      	ldr	r3, [r3, #12]
    8e08:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    8e0a:	6872      	ldr	r2, [r6, #4]
					if( xConstTickCount < xItemValue )
    8e0c:	4297      	cmp	r7, r2
    8e0e:	d340      	bcc.n	8e92 <xTaskIncrementTick+0x120>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    8e10:	1d33      	adds	r3, r6, #4
    8e12:	9301      	str	r3, [sp, #4]
    8e14:	0018      	movs	r0, r3
    8e16:	47c8      	blx	r9
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    8e18:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    8e1a:	b113      	cbz	r3, 8e22 <xTaskIncrementTick+0xb0>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    8e1c:	0030      	movs	r0, r6
    8e1e:	3018      	adds	r0, #24
    8e20:	47c8      	blx	r9
					prvAddTaskToReadyList( pxTCB );
    8e22:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    8e24:	6822      	ldr	r2, [r4, #0]
    8e26:	4293      	cmp	r3, r2
    8e28:	d900      	bls.n	8e2c <xTaskIncrementTick+0xba>
    8e2a:	6023      	str	r3, [r4, #0]
    8e2c:	0098      	lsls	r0, r3, #2
    8e2e:	18c0      	adds	r0, r0, r3
    8e30:	0080      	lsls	r0, r0, #2
    8e32:	4450      	add	r0, sl
    8e34:	9901      	ldr	r1, [sp, #4]
    8e36:	f248 43b7 	movw	r3, #33975	; 0x84b7
    8e3a:	f2c0 0300 	movt	r3, #0
    8e3e:	4798      	blx	r3
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    8e40:	6863      	ldr	r3, [r4, #4]
    8e42:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    8e44:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8e46:	429a      	cmp	r2, r3
    8e48:	d3d9      	bcc.n	8dfe <xTaskIncrementTick+0x8c>
							xSwitchRequired = pdTRUE;
    8e4a:	2501      	movs	r5, #1
    8e4c:	e7d7      	b.n	8dfe <xTaskIncrementTick+0x8c>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    8e4e:	f243 1324 	movw	r3, #12580	; 0x3124
    8e52:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8e56:	2201      	movs	r2, #1
    8e58:	4252      	negs	r2, r2
    8e5a:	66da      	str	r2, [r3, #108]	; 0x6c
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    8e5c:	f243 1324 	movw	r3, #12580	; 0x3124
    8e60:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8e64:	685b      	ldr	r3, [r3, #4]
    8e66:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    8e68:	0093      	lsls	r3, r2, #2
    8e6a:	189b      	adds	r3, r3, r2
    8e6c:	009b      	lsls	r3, r3, #2
    8e6e:	f243 1224 	movw	r2, #12580	; 0x3124
    8e72:	f2c2 0200 	movt	r2, #8192	; 0x2000
    8e76:	4694      	mov	ip, r2
    8e78:	4463      	add	r3, ip
    8e7a:	689b      	ldr	r3, [r3, #8]
    8e7c:	2b01      	cmp	r3, #1
    8e7e:	d900      	bls.n	8e82 <xTaskIncrementTick+0x110>
				xSwitchRequired = pdTRUE;
    8e80:	2501      	movs	r5, #1
			if( xYieldPending != pdFALSE )
    8e82:	f243 13a4 	movw	r3, #12708	; 0x31a4
    8e86:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8e8a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    8e8c:	b17b      	cbz	r3, 8eae <xTaskIncrementTick+0x13c>
				xSwitchRequired = pdTRUE;
    8e8e:	2501      	movs	r5, #1
    8e90:	e00d      	b.n	8eae <xTaskIncrementTick+0x13c>
						xNextTaskUnblockTime = xItemValue;
    8e92:	f243 1324 	movw	r3, #12580	; 0x3124
    8e96:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8e9a:	66da      	str	r2, [r3, #108]	; 0x6c
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
    8e9c:	e7de      	b.n	8e5c <xTaskIncrementTick+0xea>
		++xPendedTicks;
    8e9e:	f243 13a4 	movw	r3, #12708	; 0x31a4
    8ea2:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8ea6:	6fda      	ldr	r2, [r3, #124]	; 0x7c
    8ea8:	3201      	adds	r2, #1
    8eaa:	67da      	str	r2, [r3, #124]	; 0x7c
BaseType_t xSwitchRequired = pdFALSE;
    8eac:	2500      	movs	r5, #0
}
    8eae:	0028      	movs	r0, r5
    8eb0:	b003      	add	sp, #12
    8eb2:	bc0c      	pop	{r2, r3}
    8eb4:	4691      	mov	r9, r2
    8eb6:	469a      	mov	sl, r3
    8eb8:	bdf0      	pop	{r4, r5, r6, r7, pc}

00008eba <xTaskResumeAll>:
{
    8eba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8ebc:	46ce      	mov	lr, r9
    8ebe:	4647      	mov	r7, r8
    8ec0:	b580      	push	{r7, lr}
	configASSERT( uxSchedulerSuspended );
    8ec2:	f243 13a4 	movw	r3, #12708	; 0x31a4
    8ec6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8eca:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    8ecc:	b90b      	cbnz	r3, 8ed2 <xTaskResumeAll+0x18>
    8ece:	b672      	cpsid	i
    8ed0:	e7fe      	b.n	8ed0 <xTaskResumeAll+0x16>
	taskENTER_CRITICAL();
    8ed2:	f248 6311 	movw	r3, #34321	; 0x8611
    8ed6:	f2c0 0300 	movt	r3, #0
    8eda:	4798      	blx	r3
		--uxSchedulerSuspended;
    8edc:	f243 13a4 	movw	r3, #12708	; 0x31a4
    8ee0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8ee4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    8ee6:	3a01      	subs	r2, #1
    8ee8:	671a      	str	r2, [r3, #112]	; 0x70
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    8eea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
BaseType_t xAlreadyYielded = pdFALSE;
    8eec:	2400      	movs	r4, #0
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    8eee:	b933      	cbnz	r3, 8efe <xTaskResumeAll+0x44>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    8ef0:	f243 1324 	movw	r3, #12580	; 0x3124
    8ef4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8ef8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    8efa:	2500      	movs	r5, #0
    8efc:	b94b      	cbnz	r3, 8f12 <xTaskResumeAll+0x58>
	taskEXIT_CRITICAL();
    8efe:	f248 632b 	movw	r3, #34347	; 0x862b
    8f02:	f2c0 0300 	movt	r3, #0
    8f06:	4798      	blx	r3
}
    8f08:	0020      	movs	r0, r4
    8f0a:	bc0c      	pop	{r2, r3}
    8f0c:	4690      	mov	r8, r2
    8f0e:	4699      	mov	r9, r3
    8f10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    8f12:	f243 17a4 	movw	r7, #12708	; 0x31a4
    8f16:	f2c2 0700 	movt	r7, #8192	; 0x2000
					prvAddTaskToReadyList( pxTCB );
    8f1a:	f243 1624 	movw	r6, #12580	; 0x3124
    8f1e:	f2c2 0600 	movt	r6, #8192	; 0x2000
    8f22:	f240 0808 	movw	r8, #8
    8f26:	44b0      	add	r8, r6
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    8f28:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8f2a:	b313      	cbz	r3, 8f72 <xTaskResumeAll+0xb8>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    8f2c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    8f2e:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    8f30:	0028      	movs	r0, r5
    8f32:	3018      	adds	r0, #24
    8f34:	f248 49cf 	movw	r9, #33999	; 0x84cf
    8f38:	f2c0 0900 	movt	r9, #0
    8f3c:	47c8      	blx	r9
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    8f3e:	1d2c      	adds	r4, r5, #4
    8f40:	0020      	movs	r0, r4
    8f42:	47c8      	blx	r9
					prvAddTaskToReadyList( pxTCB );
    8f44:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    8f46:	6832      	ldr	r2, [r6, #0]
    8f48:	4293      	cmp	r3, r2
    8f4a:	d900      	bls.n	8f4e <xTaskResumeAll+0x94>
    8f4c:	6033      	str	r3, [r6, #0]
    8f4e:	0098      	lsls	r0, r3, #2
    8f50:	18c0      	adds	r0, r0, r3
    8f52:	0080      	lsls	r0, r0, #2
    8f54:	4440      	add	r0, r8
    8f56:	0021      	movs	r1, r4
    8f58:	f248 43b7 	movw	r3, #33975	; 0x84b7
    8f5c:	f2c0 0300 	movt	r3, #0
    8f60:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    8f62:	6873      	ldr	r3, [r6, #4]
    8f64:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    8f66:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    8f68:	429a      	cmp	r2, r3
    8f6a:	d3dd      	bcc.n	8f28 <xTaskResumeAll+0x6e>
						xYieldPending = pdTRUE;
    8f6c:	2301      	movs	r3, #1
    8f6e:	67bb      	str	r3, [r7, #120]	; 0x78
    8f70:	e7da      	b.n	8f28 <xTaskResumeAll+0x6e>
				if( pxTCB != NULL )
    8f72:	b125      	cbz	r5, 8f7e <xTaskResumeAll+0xc4>
					prvResetNextTaskUnblockTime();
    8f74:	f648 13ad 	movw	r3, #35245	; 0x89ad
    8f78:	f2c0 0300 	movt	r3, #0
    8f7c:	4798      	blx	r3
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    8f7e:	f243 13a4 	movw	r3, #12708	; 0x31a4
    8f82:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8f86:	6fdc      	ldr	r4, [r3, #124]	; 0x7c
					if( xPendedCounts > ( TickType_t ) 0U )
    8f88:	b19c      	cbz	r4, 8fb2 <xTaskResumeAll+0xf8>
							if( xTaskIncrementTick() != pdFALSE )
    8f8a:	f648 5673 	movw	r6, #36211	; 0x8d73
    8f8e:	f2c0 0600 	movt	r6, #0
								xYieldPending = pdTRUE;
    8f92:	001d      	movs	r5, r3
    8f94:	2701      	movs	r7, #1
    8f96:	e001      	b.n	8f9c <xTaskResumeAll+0xe2>
							--xPendedCounts;
    8f98:	3c01      	subs	r4, #1
						} while( xPendedCounts > ( TickType_t ) 0U );
    8f9a:	b124      	cbz	r4, 8fa6 <xTaskResumeAll+0xec>
							if( xTaskIncrementTick() != pdFALSE )
    8f9c:	47b0      	blx	r6
    8f9e:	2800      	cmp	r0, #0
    8fa0:	d0fa      	beq.n	8f98 <xTaskResumeAll+0xde>
								xYieldPending = pdTRUE;
    8fa2:	67af      	str	r7, [r5, #120]	; 0x78
    8fa4:	e7f8      	b.n	8f98 <xTaskResumeAll+0xde>
						xPendedTicks = 0;
    8fa6:	f243 13a4 	movw	r3, #12708	; 0x31a4
    8faa:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8fae:	2200      	movs	r2, #0
    8fb0:	67da      	str	r2, [r3, #124]	; 0x7c
				if( xYieldPending != pdFALSE )
    8fb2:	f243 13a4 	movw	r3, #12708	; 0x31a4
    8fb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
    8fba:	6f9b      	ldr	r3, [r3, #120]	; 0x78
BaseType_t xAlreadyYielded = pdFALSE;
    8fbc:	2400      	movs	r4, #0
				if( xYieldPending != pdFALSE )
    8fbe:	2b00      	cmp	r3, #0
    8fc0:	d09d      	beq.n	8efe <xTaskResumeAll+0x44>
					taskYIELD_IF_USING_PREEMPTION();
    8fc2:	f248 53f9 	movw	r3, #34297	; 0x85f9
    8fc6:	f2c0 0300 	movt	r3, #0
    8fca:	4798      	blx	r3
						xAlreadyYielded = pdTRUE;
    8fcc:	3401      	adds	r4, #1
    8fce:	e796      	b.n	8efe <xTaskResumeAll+0x44>

00008fd0 <prvIdleTask>:
{
    8fd0:	b5f0      	push	{r4, r5, r6, r7, lr}
    8fd2:	46c6      	mov	lr, r8
    8fd4:	b500      	push	{lr}
	portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
    8fd6:	f240 4000 	movw	r0, #1024	; 0x400
    8fda:	f648 1365 	movw	r3, #35173	; 0x8965
    8fde:	f2c0 0300 	movt	r3, #0
    8fe2:	4798      	blx	r3
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    8fe4:	f243 14a4 	movw	r4, #12708	; 0x31a4
    8fe8:	f2c2 0400 	movt	r4, #8192	; 0x2000
			taskENTER_CRITICAL();
    8fec:	f248 6811 	movw	r8, #34321	; 0x8611
    8ff0:	f2c0 0800 	movt	r8, #0
    8ff4:	e045      	b.n	9082 <prvIdleTask+0xb2>
			xExpectedIdleTime = prvGetExpectedIdleTime();
    8ff6:	f648 1377 	movw	r3, #35191	; 0x8977
    8ffa:	f2c0 0300 	movt	r3, #0
    8ffe:	4798      	blx	r3
			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
    9000:	2801      	cmp	r0, #1
    9002:	d827      	bhi.n	9054 <prvIdleTask+0x84>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    9004:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    9006:	b1e3      	cbz	r3, 9042 <prvIdleTask+0x72>
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    9008:	f248 46cf 	movw	r6, #33999	; 0x84cf
    900c:	f2c0 0600 	movt	r6, #0
			taskENTER_CRITICAL();
    9010:	47c0      	blx	r8
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    9012:	6c63      	ldr	r3, [r4, #68]	; 0x44
    9014:	68df      	ldr	r7, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    9016:	1d38      	adds	r0, r7, #4
    9018:	47b0      	blx	r6
				--uxCurrentNumberOfTasks;
    901a:	6fab      	ldr	r3, [r5, #120]	; 0x78
    901c:	3b01      	subs	r3, #1
    901e:	67ab      	str	r3, [r5, #120]	; 0x78
				--uxDeletedTasksWaitingCleanUp;
    9020:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    9022:	3b01      	subs	r3, #1
    9024:	66e3      	str	r3, [r4, #108]	; 0x6c
			taskEXIT_CRITICAL();
    9026:	f248 632b 	movw	r3, #34347	; 0x862b
    902a:	f2c0 0300 	movt	r3, #0
    902e:	4798      	blx	r3
			prvDeleteTCB( pxTCB );
    9030:	0038      	movs	r0, r7
    9032:	f648 33e3 	movw	r3, #35811	; 0x8be3
    9036:	f2c0 0300 	movt	r3, #0
    903a:	4798      	blx	r3
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    903c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    903e:	2b00      	cmp	r3, #0
    9040:	d1e6      	bne.n	9010 <prvIdleTask+0x40>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    9042:	68ab      	ldr	r3, [r5, #8]
    9044:	2b01      	cmp	r3, #1
    9046:	d9d6      	bls.n	8ff6 <prvIdleTask+0x26>
				taskYIELD();
    9048:	f248 53f9 	movw	r3, #34297	; 0x85f9
    904c:	f2c0 0300 	movt	r3, #0
    9050:	4798      	blx	r3
    9052:	e7d0      	b.n	8ff6 <prvIdleTask+0x26>
				vTaskSuspendAll();
    9054:	f648 5363 	movw	r3, #36195	; 0x8d63
    9058:	f2c0 0300 	movt	r3, #0
    905c:	4798      	blx	r3
					configASSERT( xNextTaskUnblockTime >= xTickCount );
    905e:	f243 1324 	movw	r3, #12580	; 0x3124
    9062:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9066:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    9068:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    906a:	429a      	cmp	r2, r3
    906c:	d30e      	bcc.n	908c <prvIdleTask+0xbc>
					xExpectedIdleTime = prvGetExpectedIdleTime();
    906e:	f648 1377 	movw	r3, #35191	; 0x8977
    9072:	f2c0 0300 	movt	r3, #0
    9076:	4798      	blx	r3
				( void ) xTaskResumeAll();
    9078:	f648 63bb 	movw	r3, #36539	; 0x8ebb
    907c:	f2c0 0300 	movt	r3, #0
    9080:	4798      	blx	r3
				--uxCurrentNumberOfTasks;
    9082:	f243 1524 	movw	r5, #12580	; 0x3124
    9086:	f2c2 0500 	movt	r5, #8192	; 0x2000
    908a:	e7bb      	b.n	9004 <prvIdleTask+0x34>
					configASSERT( xNextTaskUnblockTime >= xTickCount );
    908c:	b672      	cpsid	i
    908e:	e7fe      	b.n	908e <prvIdleTask+0xbe>

00009090 <vTaskSwitchContext>:
{
    9090:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    9092:	f243 13a4 	movw	r3, #12708	; 0x31a4
    9096:	f2c2 0300 	movt	r3, #8192	; 0x2000
    909a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    909c:	2b00      	cmp	r3, #0
    909e:	d146      	bne.n	912e <vTaskSwitchContext+0x9e>
		xYieldPending = pdFALSE;
    90a0:	f243 13a4 	movw	r3, #12708	; 0x31a4
    90a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
    90a8:	2200      	movs	r2, #0
    90aa:	679a      	str	r2, [r3, #120]	; 0x78
		taskCHECK_FOR_STACK_OVERFLOW();
    90ac:	f243 1324 	movw	r3, #12580	; 0x3124
    90b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    90b4:	685b      	ldr	r3, [r3, #4]
    90b6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    90b8:	f24a 52a5 	movw	r2, #42405	; 0xa5a5
    90bc:	f2ca 52a5 	movt	r2, #42405	; 0xa5a5
    90c0:	6819      	ldr	r1, [r3, #0]
    90c2:	4291      	cmp	r1, r2
    90c4:	d106      	bne.n	90d4 <vTaskSwitchContext+0x44>
    90c6:	f24a 52a5 	movw	r2, #42405	; 0xa5a5
    90ca:	f2ca 52a5 	movt	r2, #42405	; 0xa5a5
    90ce:	6859      	ldr	r1, [r3, #4]
    90d0:	4291      	cmp	r1, r2
    90d2:	d033      	beq.n	913c <vTaskSwitchContext+0xac>
    90d4:	f243 1324 	movw	r3, #12580	; 0x3124
    90d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
    90dc:	6858      	ldr	r0, [r3, #4]
    90de:	6859      	ldr	r1, [r3, #4]
    90e0:	3134      	adds	r1, #52	; 0x34
    90e2:	f248 5381 	movw	r3, #34177	; 0x8581
    90e6:	f2c0 0300 	movt	r3, #0
    90ea:	4798      	blx	r3
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    90ec:	f243 1324 	movw	r3, #12580	; 0x3124
    90f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
    90f4:	681b      	ldr	r3, [r3, #0]
    90f6:	009a      	lsls	r2, r3, #2
    90f8:	18d2      	adds	r2, r2, r3
    90fa:	0092      	lsls	r2, r2, #2
    90fc:	f243 1124 	movw	r1, #12580	; 0x3124
    9100:	f2c2 0100 	movt	r1, #8192	; 0x2000
    9104:	468c      	mov	ip, r1
    9106:	4462      	add	r2, ip
    9108:	6892      	ldr	r2, [r2, #8]
    910a:	bb32      	cbnz	r2, 915a <vTaskSwitchContext+0xca>
    910c:	b16b      	cbz	r3, 912a <vTaskSwitchContext+0x9a>
    910e:	3b01      	subs	r3, #1
    9110:	009a      	lsls	r2, r3, #2
    9112:	18d2      	adds	r2, r2, r3
    9114:	0092      	lsls	r2, r2, #2
    9116:	f243 1124 	movw	r1, #12580	; 0x3124
    911a:	f2c2 0100 	movt	r1, #8192	; 0x2000
    911e:	468c      	mov	ip, r1
    9120:	4462      	add	r2, ip
    9122:	6892      	ldr	r2, [r2, #8]
    9124:	b9ca      	cbnz	r2, 915a <vTaskSwitchContext+0xca>
    9126:	2b00      	cmp	r3, #0
    9128:	d1f1      	bne.n	910e <vTaskSwitchContext+0x7e>
    912a:	b672      	cpsid	i
    912c:	e7fe      	b.n	912c <vTaskSwitchContext+0x9c>
		xYieldPending = pdTRUE;
    912e:	f243 13a4 	movw	r3, #12708	; 0x31a4
    9132:	f2c2 0300 	movt	r3, #8192	; 0x2000
    9136:	2201      	movs	r2, #1
    9138:	679a      	str	r2, [r3, #120]	; 0x78
}
    913a:	bd10      	pop	{r4, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
    913c:	f24a 52a5 	movw	r2, #42405	; 0xa5a5
    9140:	f2ca 52a5 	movt	r2, #42405	; 0xa5a5
    9144:	6899      	ldr	r1, [r3, #8]
    9146:	4291      	cmp	r1, r2
    9148:	d1c4      	bne.n	90d4 <vTaskSwitchContext+0x44>
    914a:	f24a 52a5 	movw	r2, #42405	; 0xa5a5
    914e:	f2ca 52a5 	movt	r2, #42405	; 0xa5a5
    9152:	68db      	ldr	r3, [r3, #12]
    9154:	4293      	cmp	r3, r2
    9156:	d1bd      	bne.n	90d4 <vTaskSwitchContext+0x44>
    9158:	e7c8      	b.n	90ec <vTaskSwitchContext+0x5c>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    915a:	009a      	lsls	r2, r3, #2
    915c:	18d1      	adds	r1, r2, r3
    915e:	0089      	lsls	r1, r1, #2
    9160:	f243 1024 	movw	r0, #12580	; 0x3124
    9164:	f2c2 0000 	movt	r0, #8192	; 0x2000
    9168:	4684      	mov	ip, r0
    916a:	4461      	add	r1, ip
    916c:	68c8      	ldr	r0, [r1, #12]
    916e:	6840      	ldr	r0, [r0, #4]
    9170:	60c8      	str	r0, [r1, #12]
    9172:	18d2      	adds	r2, r2, r3
    9174:	0092      	lsls	r2, r2, #2
    9176:	4462      	add	r2, ip
    9178:	3210      	adds	r2, #16
    917a:	4290      	cmp	r0, r2
    917c:	d00d      	beq.n	919a <vTaskSwitchContext+0x10a>
    917e:	f243 1124 	movw	r1, #12580	; 0x3124
    9182:	f2c2 0100 	movt	r1, #8192	; 0x2000
    9186:	009a      	lsls	r2, r3, #2
    9188:	18d2      	adds	r2, r2, r3
    918a:	0092      	lsls	r2, r2, #2
    918c:	468c      	mov	ip, r1
    918e:	4462      	add	r2, ip
    9190:	68d2      	ldr	r2, [r2, #12]
    9192:	68d2      	ldr	r2, [r2, #12]
    9194:	604a      	str	r2, [r1, #4]
    9196:	600b      	str	r3, [r1, #0]
}
    9198:	e7cf      	b.n	913a <vTaskSwitchContext+0xaa>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    919a:	6841      	ldr	r1, [r0, #4]
    919c:	009a      	lsls	r2, r3, #2
    919e:	18d2      	adds	r2, r2, r3
    91a0:	0092      	lsls	r2, r2, #2
    91a2:	4462      	add	r2, ip
    91a4:	60d1      	str	r1, [r2, #12]
    91a6:	e7ea      	b.n	917e <vTaskSwitchContext+0xee>

000091a8 <__libc_init_array>:
    91a8:	b570      	push	{r4, r5, r6, lr}
    91aa:	2500      	movs	r5, #0
    91ac:	4b0e      	ldr	r3, [pc, #56]	; (91e8 <__libc_init_array+0x40>)
    91ae:	4c0f      	ldr	r4, [pc, #60]	; (91ec <__libc_init_array+0x44>)
    91b0:	1ae4      	subs	r4, r4, r3
    91b2:	10a4      	asrs	r4, r4, #2
    91b4:	42a5      	cmp	r5, r4
    91b6:	d109      	bne.n	91cc <__libc_init_array+0x24>
    91b8:	2500      	movs	r5, #0
    91ba:	f000 f83f 	bl	923c <_init>
    91be:	4c0c      	ldr	r4, [pc, #48]	; (91f0 <__libc_init_array+0x48>)
    91c0:	4b0c      	ldr	r3, [pc, #48]	; (91f4 <__libc_init_array+0x4c>)
    91c2:	1ae4      	subs	r4, r4, r3
    91c4:	10a4      	asrs	r4, r4, #2
    91c6:	42a5      	cmp	r5, r4
    91c8:	d107      	bne.n	91da <__libc_init_array+0x32>
    91ca:	bd70      	pop	{r4, r5, r6, pc}
    91cc:	4a06      	ldr	r2, [pc, #24]	; (91e8 <__libc_init_array+0x40>)
    91ce:	00ab      	lsls	r3, r5, #2
    91d0:	189b      	adds	r3, r3, r2
    91d2:	681b      	ldr	r3, [r3, #0]
    91d4:	4798      	blx	r3
    91d6:	3501      	adds	r5, #1
    91d8:	e7ec      	b.n	91b4 <__libc_init_array+0xc>
    91da:	4a06      	ldr	r2, [pc, #24]	; (91f4 <__libc_init_array+0x4c>)
    91dc:	00ab      	lsls	r3, r5, #2
    91de:	189b      	adds	r3, r3, r2
    91e0:	681b      	ldr	r3, [r3, #0]
    91e2:	4798      	blx	r3
    91e4:	3501      	adds	r5, #1
    91e6:	e7ee      	b.n	91c6 <__libc_init_array+0x1e>
    91e8:	00009248 	.word	0x00009248
    91ec:	00009248 	.word	0x00009248
    91f0:	0000924c 	.word	0x0000924c
    91f4:	00009248 	.word	0x00009248

000091f8 <memset>:
    91f8:	0003      	movs	r3, r0
    91fa:	1882      	adds	r2, r0, r2
    91fc:	4293      	cmp	r3, r2
    91fe:	d100      	bne.n	9202 <memset+0xa>
    9200:	4770      	bx	lr
    9202:	7019      	strb	r1, [r3, #0]
    9204:	3301      	adds	r3, #1
    9206:	e7f9      	b.n	91fc <memset+0x4>
    9208:	6c6c6568 	.word	0x6c6c6568
    920c:	6d6c2c6f 	.word	0x6d6c2c6f
    9210:	73617420 	.word	0x73617420
    9214:	0a0d316b 	.word	0x0a0d316b
    9218:	00000000 	.word	0x00000000
    921c:	6b736154 	.word	0x6b736154
    9220:	00003120 	.word	0x00003120
    9224:	454c4449 	.word	0x454c4449
    9228:	00000000 	.word	0x00000000
    922c:	09632509 	.word	0x09632509
    9230:	25097525 	.word	0x25097525
    9234:	75250975 	.word	0x75250975
    9238:	00000a0d 	.word	0x00000a0d

0000923c <_init>:
    923c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    923e:	46c0      	nop			; (mov r8, r8)
    9240:	bcf8      	pop	{r3, r4, r5, r6, r7}
    9242:	bc08      	pop	{r3}
    9244:	469e      	mov	lr, r3
    9246:	4770      	bx	lr

00009248 <__init_array_start>:
    9248:	00008121 	.word	0x00008121

0000924c <_fini>:
    924c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    924e:	46c0      	nop			; (mov r8, r8)
    9250:	bcf8      	pop	{r3, r4, r5, r6, r7}
    9252:	bc08      	pop	{r3}
    9254:	469e      	mov	lr, r3
    9256:	4770      	bx	lr

00009258 <__fini_array_start>:
    9258:	000080f5 	.word	0x000080f5
